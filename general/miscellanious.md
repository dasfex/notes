# miscellanious

1. Концепция написания LRU-кеша.
2. Логика написания структуры данных, основанной на хешировании.
3. Источники.

## Концепция написания LRU-кеша

LRU-кеш представляет из себя самую простую версию кеша,
которая хранит некоторое количество k последних запрошенных
значений.

Рассмотрим идею того, как можно эффективно реализовать 
такую структуру(этот подход является эффективным и находит
применение в других местах, например в хеш-таблицах).

Пусть мы хотим хранить некоторый тип T, который
должен быть хешируемым.

Будем хранить двусвязный список, который будет хранить
k последних запрошенных элементов, причём
чем ближе элемент к концу, тем раньше всего он запрашивался(
соответственно, чем ближе к началу, тем позже).
Заведём хеш таблицу, которая будет ставить в соответствие 
элементу итератор на ноду листа, в которой на данный момент
находится текущий элемент.
Как только мы получаем итератор на ноду, мы переставляем её
в начало листа.
Если же элемента в листе нет, удаляем последний элемент листа,
а в начало вставляем текущий.
Таким образом амортизированно за O(1) мы умеем делать все операции,
достигнув требуемого результат.

[C++](https://github.com/dasfex/ProgrammingPractice/blob/master/cpp/algos/lrucache.h),
[Golang](https://github.com/dasfex/ProgrammingPractice/blob/master/golang/lrucache.go).

## Логика написания структуры данных, основанной на хешировании.

Для начала выделим память для одного бакета.
Будем добавлять элементы в структуру, пока
max_load_factor = кол-во элементов / кол-во бакетов
не превысит некоторое значение, например 2.
Как только это происходит, увеличиваем кол-во бакетов
в какое-то кол-во раз(опять же можно в 2) и переносим все прошлые
элементы в новые бакеты.
Так же во время релокации можно сменить и хеш-функцию.

Для разрешения коллизий можно использовать любой удобный способ
адресации: открытый или закрытый.

Однако можно немного модифицировать нашу структуру,
чтобы обход всех элементов происходил на за время от кол-ва бакетов,
а за время от кол-ва самих элементов, используя идею из
[LRU-кеша](https://github.com/dasfex/ProgrammingNotes/blob/master/general/lru_cache.md).

Будет параллельно хранить двунаправленный лист, в котором будем собственно хранить
сами элементы, а в бакете будем хранить не элемент,
а итератор на ноду листа, в которой начинается цепочка элементов с
подходящим хешом, а так же можно количество элементов с таким хешом.
Как только приходит новый элемент, мы, вычисляя хеш, получаем ноду,
которая является первой в цепочке элементов с конкретным хешом,
перед ней вставляем новую ноду, а в бакете кроме увеличения значения
перезапоминаем прошлую ноду на только что вставленную.
Если мы вставляем элемент с таким хешом впервые,
то можно новую ноду вставлять например в конец листа(или в начало, как удобно).
Таким образом, в случае, когда нам потребуется обойти все существующие
элементы, мы просто обойдём этот лист за кол-во элементов.

## Источники
1. [Designing a Fast, Efficient, Cache-friendly Hash Table, Step by Step](
   https://www.youtube.com/watch?v=ncHmEUmJZf4
   ).


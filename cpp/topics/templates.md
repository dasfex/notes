# templates

### Non-type template parameters

Всем известно, что в качестве шаблонов можно использовать также примитивные
числовые типы: ```int```, ```size_t```, ```bool``` и т.д.(в противоположность
```double``` и ```float```).

Но малоизвестен тот факт, что также можно использовать указатели:
```cpp
template <typename T, T* Ptr>
class MyClass {};
```
Может возникнуть вопрос, где же взять указатель кроме ```nullptr``` в compile time.
Например вот:
```cpp
static const int values[] = {4, 8, 15, 16, 23, 42};
MyClass <const int, values> myClass;

static char magic = '*';
MyClass <char, &magic> myClass2;
```
Это может быть полезно, если вам нужно дать имя своему классу. 
Можно так же передать указатель на функцию. 

### Template template parameters

Можно задавать в шаблонах типы, которые сами являются шаблонными.
На примере стека:
```cpp
template <template <typename> class Container>
struct Stack {
  Container<int> cont;
};
...
Stack<std::vector> stack;
```
Но вообще ```std::stack``` реализован примерно вот так:
```cpp
template <typename T, template <typename> class Container = std::deque>
struct stack {
  Container<T> cont;
};
...
stack<int> s1;
stack<bool, std::vector> s2;
```
Обратим внимание, что до C++17 мы обязаны писать именно слово ```class```, а не ```typename```.
После уже не принципиально.

### Explicit instantiation

Как известно, компиляция шаблонов происходит в два этапа: 
проверка каких-то базовых моментов до подстановки типа и после подстановки.
Сама подстановка называется инстанцированием. 
Не будем рассматривать, что это такое, т.к. эта тема хорошо покрыта во множестве источников.
Отметим более редкие моменты.

Существует способ осуществить явную подстановку типа, чтобы проверить, компилируются ли все
компоненты класса(поля, методы) без их явного вызова.
```cpp
template <typename T, size_T N>
struct S {
  void f() {
    T a[N];
  }
};

// explicit instantiation
template struct S<int, -1>;
```
Обычно мы получили бы ошибку только при инстанцировании структуры, но так этого можно не делать.

### Variadic templates(since C++11)

Следующим логичным шагом было бы введение шаблонов с переменным количеством аргументов:
```cpp
// отделяем первый аргумент от остальных
template <typename Head, typename... Args>
void print(const Head& head, const Args&... args) {
  std::cout << head << ' ';
  print(args...);
}
// делаем перегрузку на случай пустого пакетв
void print() {}
```
```Args``` - это некоторая абстрактная сущность, обозначащая список типов.
Над ним можно делать распаковку с помощью троеточия, т.е. компилятор развернёт
аргументы функции в ```const T1&, constT2&``` и т.д.
А ещё мы можем давать ему имя(например ```args```).

Напишем ещё один type_trait ```is_homogeneous```(равны ли все типы):
```cpp
template <typename First, typename Second, typename... Tail>
struct is_homogeneous {
  static const bool value = std::is_same_v<First, Second> && is_homogeneous<Second, Tail...>::value;
};

template <typename T, typename U>
struct is_homogeneous<T, U> {
  static const bool value = std::is_same_v<T, U>;
};
```
Что делаеть, если мы хотим узнать кол-во типов в пакете?
Для этого существует специальный оператор:
```cpp
sizeof...(Args);
sizeof...(args);
```
### Fold expressions(since C++17)

> Как это делаллось до C++17: [link](https://articles.emptycrate.com/2016/05/14/folds_in_cpp11_ish.html).

Это возможность языка сделать что-то для всех элементов пакета сразу
(при этом не нужно писать рекурсию).
```cpp
template <typename... Args>
void print(const Args&... args) {
  (std::cout << ... << args) << '\n';
}
```
По факту мы можем писать вот так:
```
(... binary_operator args)
```
и это превратится в
```
(args1 binary_operator args2 binary_operator ...)
```
Существует 4 формы fold expressions:
```
(... op args) -> (((args1 op args2) op args3) ... )
(args op ...) (args1 op (args2 op ... (argsn)...))
(x op ... op args)
(args op ... op x)
```
где ```x``` - некоторый аргумент. 

### Управление инстанцированием шаблона функций

Предположим мы имеем некоторый шаблон функции в хедере, который включаем в 2 файла,
которые используют этот шаблон функции с одним и тем же типом шаблона. 
В таком случае инстанцирование шаблона произойдёт в каждом использующем файле. 
А что делать, если у нас не одна функция, а 500. 
И файлов, использующих каждую, по 100.
Мы очень сильно увеличим время компиляции и размер конечного объектного файла. 
Что можно сделать?

Существует синтаксис для запрета инстанцирования шаблона функции конкретным типом(например ```int```):
```cpp
extern template int max<int, int>(int, int);
```

Напишем это сразу после определения шаблона функции в хедере. 
Соответственно в каждом исходнике, где используется хедер, инстанцирование будет запрещено. 
И заведём ещё один исходник, в котором явно инстанцируем шаблон:
```cpp
template int max<int, int>(int, int);
```
Теперь мы получили довольно симметричное для каждой исходника решение,
которое позволяет использовать инстанцированный шаблон функции. 
Особенно удобно, что не нужно никаких дополнительных действий при создании
новых файлов. 

### Проблемы специализации

```cpp
template <class T> My {};
My<int> my;
template <> My<int> {}; // compile error
```
Пример довольно странный, но тем не менее, последняя строка не скомпилируется в силу того, что 
для ```int``` шаблон уже инстанцирован. 

Рассмотрим такой код:
```cpp
template <class T> void f(T);
template <class T> void f(T*);
template <> void f(int*); // компилятор имеет достаточно информации, чтобы правильно вывести тип шаблона

int x;
f(&x);
```
Очевидно, что выберется третий вариант функции ```f```, т.к. сначала выберется более частный случай(```T*```),
а потом его специализация. 

Но что если расположить следующим образом:
```cpp
template <class T> void f(T);
template <> void f(int*);
template <class T> void f(T*);
```
Тут специализация уже выбрала, что она специализирует первый шаблон, потому из двух шаблонов
будет выбран более частный, а потом выбор среди их перегрузок. 
Потому выберется 3 вариант. 

Рассмотрим ещё такой пример:
```cpp
template <class T, class U> void f(T, U);
template <class T, class U> void f(T*, U*);
template <> void f<int*, int*>(int*, int*);

int x;
f(&x, &x);
```
Будет вызвана функция с номером 2. 
3я является специализацией первого(т.к. типы в шаблоне и параметрах совпадают), 
а во время выбора шаблона предпочтение будет отдано второму. 

Специализации, как и перегрузки, можно явно запрещать:
```cpp
template <> void f<char>() = delete;
```

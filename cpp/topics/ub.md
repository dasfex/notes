# Undefined behaviour(неопределённое поведение)

Неопределённое поведение — поведение, которое может возникать 
в результате использования ошибочных программных конструкций или некорректных данных, 
на которые Международный Стандарт не налагает никаких требований. 
Неопределенное поведение также может возникать в ситуациях, не описанных в Стандарте явно.

Тут я попробую собрать примеры очевидного(и не очень) неопределённого поведения в C++.

### Захват переменных в лямбда-функции

Давайте представим вот такую ситуацию:
```cpp
class Div {
  int divisor;
  
 public:
  Div(int div) : divisor(div) {}

  auto get() {
    return [&](int n) {return n % divisor;};
  }
};
...
auto f = Div(10).get();
auto res = f(12);
```

Получаем ub.
Кажется, что тут очевидна проблема(захват переменных по ссылке).
Давайте исправим:
```cpp
...
auto get() {
  return [=](int n) {return n % divisor;};
}
... 
```

Вроде как всё исправили.
Однако тут тоже ub.

Почему же?

Потому что время жизни переменной(```divisor```) меньше, чем время жизни лямбда-функции.

Вы скажете, что мы же захватили её по значению!
Но это неправда, ведь члены класса не захватываются лямбдой.
В таких случаях захватываются лишь значения в локальной области видимости функции,
потому при вызове ```f(12)``` ```divisor``` скорее всего не существует, что и ведёт к ub.

Поправить это можно вот так:
```cpp
...
auto get() {
return [divisor = divisor](int n) {return n % divisor;};
}
...
```

Также стоит помнить про неявный захват ```*this```.

Ну и вообще вот 
[тут](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f53-avoid-capturing-by-reference-in-lambdas-that-will-be-used-non-locally-including-returned-stored-on-the-heap-or-passed-to-another-thread) 
можно почитать.

### Ub при знаковом переполнении

Можно почитать вот [тут](https://codeforces.com/blog/entry/45144).

### Dangling reference

Возврат ссылки на несуществующй объект:
```cpp
int& f(int x) {
  int y = x + 1;
  return y;
}
```
### reinterpret_cast

Его конечно не надо юзать, но всё же факт есть факт.

Предположим у нас есть ```double``` и мы хотим трактовать первых 4 его байта как ```int```:
```cpp
double x = 123.2312;
std::cout << reinterpret_cast<int>(x);
```
Однако так не скомпилируется, т.к. мы не создаём новый объект, мы просто хотим посмотреть 
на существующий под другим углом.
Потому надо кастить к ```int&```:
```cpp
std::cout << reinterpret_cast<int&>(x);
```

Можно ещё вот так:
```cpp
int* p = reinterpret_cast<int*&>(x);
```
Так мы посмотрим на все 8 байт.

Прикольно конечно, но это всё ub :)

### Инициализация переменных во вложенных скоупах

```cpp
string s = "123";
{
  string s = s;
}
```
Можно подумать, что вторая переменная ```s``` будет инициализирована первой, но 
она будет пытаться инициализироваться самой собой.
Причём это очевидно ub, т.к. вы пытаетесь инициализировать объект из ещё несозданного.

### Использование объекта после вызова деструктора

Я встречал вот такой удобный способ писать операторы копирования/перемещения:

```cpp
class A {
 public:
  A(const A& a) {...}
  A(A&& a) {...}
  ~A() {...}
  
  A& operator=(const A& a) {
    if (this == &a) {
      return *this;
    }
    this->~A(); // если без this, то будет ругаться, что мы пытаемся инвертировать конструктор
    new(this) A(a);
    return *this;
  }
  
  A& operator=(A&& a) {
    if (this == &a) {
      return *this;
    }
    this->~A();     
    new(this) A(std::move(a));
    return *this;
  }
};
```
Но так писать не стоит, ведь такой код содержит ub, 
и это не явный вызов деструктора, а использование объекта после этого вызова
(собственно, об этом сказано в стандарте).
Скорее всего ничего плохого не произойдёт, 
т.к. большниство(если не все компиляторы) поддерживают подобное и ничего не ломают, 
но лучше так всё же не писать :)

### Неопределённый порядок выполнения

Стоит быть аккуратным с выражениями вида:
```cpp
i = i++ + i++;
```
Потому что тут и правда неопределён порядок выполнения операций.

### Выход указателя за границы массива

Можно почитать вот [тут](https://stackoverflow.com/questions/10473573/why-is-out-of-bounds-pointer-arithmetic-undefined-behaviour).

### Incorrect printf use

```cpp
printf("%d%, double(5));
```
Результат такого выражения не определён и зависит от платформы.
Объяснение: [belaycpp.com/2021/08/31/yet-another-reason-to-not-use-printf-or-write-c-code-in-general/](https://belaycpp.com/2021/08/31/yet-another-reason-to-not-use-printf-or-write-c-code-in-general/).

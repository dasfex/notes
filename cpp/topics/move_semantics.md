# Move-семантика

### Зачем это надо

1. Давайте рассмотри первую очевидную реализацию ```swap```:
```
template <class T>
void swap(T& x, T& y) {
  T t = x;
  x = y;
  y = t;
}
```
Очевидной проблемой является излишнее копирование(ведь в случае, если
```T``` - какой-то контейнер, то каждое присваивание тратит линейное время).

Да, у большинства контейнеров существует метод ```swap```(```v.swap(w)```),
но для каждого тяжеловесного контейнера писать такой метод как-то нерентабельно.

А представьте, если мы работаем с кастомными BigInt(которые сравниваются за линию).
И хотим отсортировать массив из таких ребят. 
Каждый такой ```swap``` будет занимать очень много времени.

2. Или давайте вспомним реализацию метода ```construct``` из аллокаторов:
```
void construct(T* p, const Args&... args) {
  new(p) T(args...);
}
```
И представим вот такую ситуацию:
```
vector<vector<int>> v;
v.push_back(vector<int>(1000000000));
```
Опуская все подробности работы ```push_back```, мы придём к тому, что
в реализации ```construct``` выше вызовется ```vector<int>(const vector<int>&)```,
т.е. конструктор копирования. Очень неприятно!

Да, конечно в таком случае можно использовать ```v.emplace_back(1000000000)```.
Тогда число будет передано в качестве аргументов, и не будет лишнего создания вектора.

Давайте представим, что у нас есть функция, возвращающая огромный вектор:
```
vector<int> f() {
  return vector<int>(1000000000);
}
...
v.push_back(f());
```
В таком случае не будет разницы между ```push_back``` и ```emplace_back```.
Придётся так и так копировать.

3. И проблема с использованием ```construct```(писали вот так):
```
traits::construct(alloc, newarr + i, arr[i]);
```
И здесь очень хочется сделать что-то более умное, чтобы не копировать
элемент.

Понятно, что в случае ```swap``` хотелось бы не просто копировать, 
а перекладывать все поля одного объекта в другой.
На примере вектора понятно, что проще переложить указатель на память, чем все элементы.

### Как надо писать, чтобы всё классно работало

Вот это правильная реализация ```swap``` для современных плюсов:
```
template <class T>
void swap(T& x, T& y) {
  T t = std::move(x);
  x = std::move(y);
  y = std::move(t);
}
```
```std::move``` просто перекладывает всё из одного объекта в другой(тот, из которого,
скорее всего становится невалидным).
Стоит понимать, что проблема 1 решена.
Но в реализации ```construct``` нельзя просто написать ```T(std::move(args)...)```,
ведь ```std::move``` инвалидирует объект, и каждый раз, когда мы клали бы что-то
в конец вектора, это становилось бы уничтоженным.
Т.е. писать ```std::move``` там нельзя, потому что будем ломать то,
что не хотели.
Но и не писать тоже нельзя: слишком долго будет работать.
Отложим эту проблему.

Давайте разберёмся, как работает то, что мы уже решили. 

### Как же реализованы конструкторы, что всё так работает

В C++11 появились новый вид конструкторов(move-конструктор).
Это конструктор, который принимает в качестве параметров нечто, что
возвращено после ```std::move```.
Давайте напишем его на примере вектора:
```
vector(vector<T>&& other) { // пока какой-то непонятный тип
  alloc = std::move(other.alloc);
  sz = other.sz;
  cp = other.cp;
  arr = other.arr;
  other.arr = nullptr;
} // по красоте надо через список инциализации
```

Аналогично пишется move-оператор присваивания.

### Когда стоит использовать конструктор перемещения

Давайте попробуем сформулировать правило, когда должен вызываться 
конструктор копирования, а когда конструктор перемещения, потому что 
понятно, что в перемещение хотелось бы отправлять не только результат
```std::move```.

Рассмотрим на примере BigInt.

Понятно, что вот такое выражение:
```
BigInt(BigInt())
```
надо бы мувать(вообще не совсем так, но чуть позже поправимся).

Или вот такое:
```
BigInt(x + y);
```
Или такое:
```
x++;
```
Но не такое:
```
++x;
```
Сформулируем правило: если выражение является lvalue, то вызовем конструктор копирования,
если rvalue, то перемещения.
Ровно это и делается.

### Что же такое rvalue/lvalue

lvalue включает в себя:
+ identifier(если выражение это просто идентификатор(просто имя переменной), 
то это lvalue(```x;```)), строковый литерал;
+ если функция возвращает reference return type(type&);
+ built-in operators: ```prefix ++, prefix --, =, op=, unary *```;
+ cast to lvalue-reference.

rvalue включает в себя:
+ любой литерал(кроме строкового);
+ если функция возвращает non-reference return type or rvalue-reference return type;
+ built-in operators: ```postfix ++, postfix --, +, -, /, *, %, <<, >>, &, |, ^, &&, ||,
==, <=, >=, <, >, !=, ~, !```;
+ cast to non-reference or rvalue-reference.

Оператор запятая имеет такой тип value, какой имеет последний операнд.

?: имеет такой, какой имеют оба возвращаемых типа, причём они должны быть одинаковыми, потому что
иначе возможна была бы ситуация ```(cond ? x : 5) = y```.

У операторов ```[]```, ```.```, ```->``` аналогично: к какому применяем, такое и получаем.

Давайте поймём, что же такое ```std::move```.

Название вводит в заблуждение: можно подумать, что она что-то перемещает, но на самом деле
она просто говорит трактовать текущий объект как rvalue-reference.

### rvalue-references properties

```
int x = 5;
int&& y; // просто вот так написать нельзя
int&& y = x; // вот так тоже нельзя, потому что справа lvalue
int&& y = std::move(x);
int&& y = static_cast<int&&>(x); // это два почти эквивалентных способа
int&& z = y; // так нельзя написать, ведь y lvalue, а нельзя биндить lvalue к rvalue-ссылкам
int& z = y; // так можно
```

### std::move

Давайте реализуем ```std::move```.

Для начала непонятно, что она должна возвращать и принимать.

Основная проблема в принимаемом значении.
Дело в том, что ```std::move``` должны уметь принимать как lvalue, так и rvalue объекты,
возвращая rvalue-ссылку.
Если мы передадим ```const T&```, то нет, потому что мы не можем биндить lvalue-ссылки
к временным объектам.
Если ```T&``` - не сможем вызывать функцию от временных объектов.
А если ```T&&``` - не сможем от невременных.

Для решения проблемы немного изменены правила вывода типов для шаблонных аргументов с 
двойным амперсандом, т.к. ```T&&``` биндится как с rvalue, так и с lvalue.
Такая ссылка называется universal reference(это неформальное понятие, не из стандарта).
Т.е. в случае ```std::move(5)``` ```T = int```, ```type(x) = int&&```.
Но если ```int y; std::move(y);```, существует правило, что в таком случае вместо ```T```
будет подставлен не просто тип, а тип с одиночным амперсандом.
В этом случае происходит так называемое reference collapsing:
если на один амперсанд навесить ещё два, останется лишь один.

Из-за этого правила возникает 2 ситуации, когда у нас тип может быт с ссылкой и без.
Но возвращать всегда нужно rvalue-ссылку. 
Так вот чтобы всегда это делать, нужно возвращать ```std::remove_reference_t<T>&&```.
```
template <class T> 
std::remove_reference_t<T>&& move(T&& x) {
  return static_cast<std::remove_reference_t<T>&&>(x);
}
```

### perfect forwarding

Мы уже решили проблему с ```std::swap```, но остались проблемы с ```push_back```
и неэффективным ```construct```.
```
void construct(T* p, const Args&... args) {
  new(p) T(args...); // почему нельзя юзать std::move, уже говорили
}
```
Теперь вместо ```const Args&``` можем написать ```Args&&&```.

И вот именно для такого места придуман этот костыль с универсальной ссылкой, т.к.
в ```std::move``` мы ещё как-то могли бы обойтись, но тут мы теперь для каждого типа 
из ```Args``` можем сохранять информацию о том, что было передано: rvalue или lvalue(
т.е. для каждого параметра мы отдельно можем понимать, стоит ли его мувать). 

Но нужно что-то ещё написать в ```T(args...)```.

Для этого существует ещё одна функция ```std::forward```: она в зависимости от типа параметра
либо кастует к rvalue, либо нет(в то время как ```std::move``` - это безусловный каст).

Для чего это надо? Каждый раз, когда мы будем передавать эти параметры, 
необходимо сохранять категорию value переменной, ведь если этого не делать, 
то при ```T(args...)``` аргументы станут lvalue независимо от количества амперсандов.

```std::forward``` позволяет сохранить категорию value.

Используется это вот так:
```
std::forward<Args>(args);
```
И тип в шаблоне либо имеет амперсанды, либо нет, в зависимости от чего происходит каст.

Как же работает ```std::forward```?
Возвращает он ```T&&```, но принимать такой же он не может, ведь придёт нам в функцию только 
lvalue.
Надо действовать в зависимости от шаблонного аргумента:
```
template <class T>
T&& forward(std::remove_reference_t<T>& x) {
  return static_cast<T&&>(x);
}
```
Теперь решена проблема с ```construct```:
```
void construct(T* p, Args&&... args) {
  new(p) T(std::forward<Args>(args)...);
}
```
А ещё мы решили проблему с ```push_back```.
Каким образом?
Скорее всего существует две реализации ```push_back```:
```
void push_back(const T&);
void push_back(T&&);
```
И стоит понимать, что во второй это rvalue-ссылка в чистом виде.
Может показаться, что это универсальная, но она была бы универсальной,
ведь универсальной ссылкой считается такая ссылка, что она имеет вид ```T&&```,
и при этом ```T``` есть шаблонный параметр этой функции.
Но тут это шаблонный параметр класса, он уже подставлен во время инстанцирования класса.
Потому это по факту то же самое, что и конструктор копирования и конструктор перемещения.
И отличаются они лишь тем, что в одном случае в конце мы пишем просто 
```construct(alloc, newarr + i, x)```, 
а во втором случае - ```construct(alloc, newarr + i, std::move(x))```.

>> Конечно можно реализовать с помощью универсальной ссылки:
>> ```
>> template <class U>
>> void push_back(U&&);
>> ```
>> И функция будет вызываться как для lvalue, так и для rvalue.
>> Но тогда в конце функции нужно будет писать 
>> ```construct(alloc, newarr + i, std::forward>U>(x))```.

Таким образом мы решили все поставленные проблемы.

### std::move_if_noexcept

Вернёмся к такой строке:
```
construct(alloc, newarr + i, std::move(arr[i]));
```
Дело в том, что ```push_back```, как и другие контейнеры, старается поддержать безопасность
относительно исключений.
Конечно не всем функциям в контейнерах это удаётся, но ```push_back``` всё-таки
реализован безопасно.

Предположим, что во время реаллокации всех элементов при перекладывании из старого
массива в новый move-конструктор на каком-то элементе бросил исключение.
Но после ```std::move``` уже переложенная часть старого массива невалидна, 
а ещё не переложенная часть нового тоже неготова.
Что в таком случае делать?
Ведь перекладывать обратно мы не можем: а вдруг вылетит второе исключение?
Потому в случае, когда move-конструктор бросает исключение, 
```push_back``` становится небезопасным относительно исключений.

В стандарте решили эту проблему вот так: вместо ```std::move``` в этом месте используется 
```std::move_if_noexcept```.
Что это такое?
Эта функция возвращает rvalue-ссылку только в том случае, если move-конструктор
является ```noexcept```, иначе возвращает lvalue-ссылку.
Реализован он вот так:
```
using ret_type = std::conditional<noexcept(T(std::move(T()))), 
		std::remove_reference_t<T>&,
		std::remove_reference_t<T>&&>;
template <class T>
ret_type move_if_noexcept(T&& x) {
  return static_cast<ret_type>(x);
}
```

### Категории выражения

На самом деле в C++11 существует не 2 категории выражений(lvalue, rvalue), а 5.

      glvalue       rvalue
     /      \      /      \
lvalue       xvalue       prvalue

glvalue = generalized lvalue.

xvalue = expired value. Это либо static_cast<T&&>, либо возвращаемый тип функции,
которая возвращает тип с двойным амперсандом. 
Смысл такой: это какой-то именованный объект, 
который вообще-то lvalue, но его почему-то решили трактовать, как rvalue.

prvalue = poor rvalue. Это всё, что rvalue и не xvalue. 
По факту это временный объект, который прямо только что на месте создали.

Различия между ними несложные, но такая классификация несёт в себе несколько удобных моментов.
Например когда мы пишем ```T(T())```, компилятор понимает, что можно не вызывать
конструктор дважды, и соптимизирует это.
В этом и различие двух видов: prvalue фактически может не иметь под собой никакой сущности, что 
позволяет иногда не создавать лишнее или как-то оптимизировать.
в то время как с xvalue так нельзя.

Это позволяет использовать такую вещь как copy elision.
Компиляторы оптимизировали такие вещи и раньше, но начиная с C++17 такое строго документированно.

copy elision - это предписание компилятору прям по стандарту оптимизировать выражения 
некоторого вида и не делать столько вызовов конструктора, сколько написано.
Если это prvalue, и сразу понятно, что получится, то не надо создавать его.
Это ещё работает когда пишем вот так:
```
T x = T();
```
Но если бы мы написали
```
T x = std::move(T());
```
мы получили бы xvalue, а xvalue обязывает создать объект, и вот тут мы получили бы
дважды вызов конструктора, но один из них перемещающий.
Это объясняет, почему иногда не надо писать ```std::move```, когда нам кажется, что надо.
Т.е. иногда он вреден.
Например ещё в такой ситуации:
```
T f() {
  T x;
  return x;
}
```
Некоторые люди пишут ```return std::move(x)```, и тут они неправы, потому что если не писать
```std::move```, то будет copy elision, что оптимальнее(объект создастся прям на месте).

Также не стоит использовать ```std::move``` из константных объектов:
```
const string s = MakeString();
vector<string> strs;
strs.push_back(std::move(s)); // бесполезно
```

Ещё упомянем такой термин как temporary materialization - это когда
prvalue кастуется к xvalue.
Например в случае, когда у prvalue вызывается метод:
```
T().f();
```

Ещё можно изучить
[```std::make_move_iterator```](https://en.cppreference.com/w/cpp/iterator/make_move_iterator).

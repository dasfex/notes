## Содержание

0. Cpp optimizations.
1. Макросы ```__FILE__```, ```__LINE__```.
2. Типы возвращаемых значений у тернарного оператора.
3. Счётчик в ```std::shared_ptr```.
4. ```using``` + ```template```.
5. Генерация имён для временных файлов.
6. Ускорение ```std::stack```.
7. Ключ в ```std::map``` и ```std::unordered_map```.
8. ```std::tie```.
9. Приоритет операторов.
10. ```static_cast```.
11. Определение pure virtual function.
12. Проблема параметров по умолчанию при наследовании.
13. User-defined deduction guides(since C++17).
14. Function-try block.
15. Перегрузка ```operator<<```.
16. Заметки о ```decltype```.
17. Возвращаемый тип ```throw```.
18. Зачем нужен ```std::invoke```.
19. Инициализация в if since C++17.
20. Использование ```return *this``` в перегрузке операторов.
21. Удобная форма написания операторов копирования/перемещения.
22. Простой способ написать итератор на вектор.

### Cpp optimizations.

1. EBCO.

```cpp
struct base {};
struct der: base {
  int a;
};
```
Чему будет равен ```sizeof(der)```? 
Зная, как работает наследование, создание пустого типа и выравнивание,
можно предположить, что 8 байт.
Однако в таких случаях происходит *Empty Base Class Optimization*:
если родитель является пустым, то его часть не создаётся в наследниках.
Т.е. ```sizeof(der)``` равен 4.

Или например можно использовать вот так: [cppstories.com/2021/no-unique-address/](https://www.cppstories.com/2021/no-unique-address/).

2. Return Value Optimization.

3. [SSO](https://stackoverflow.com/questions/3770781/why-is-sizeofstring-32).

4. [Copy elision](https://en.m.wikipedia.org/wiki/Copy_elision).

### ```__FILE__```, ```__LINE__```

Существует два макроса, с помощью которых можно узнавать
текущий файл(```__FILE__```) и текущую линию(```__LINE__```).
Очень удобно использовать в каких-либо макросах для получения
дополнительной информации. 
Например, в ```assert```:
```cpp
#define assert(expr)							\
   (static_cast<bool>(expr)						\
      ? void (0)							\
      : __assert_fail(#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
```

### Типы у тернарного оператора

Это кажется очевидным, но стоит помнить, что оба значения/выражения,
которые возвращает тернарный оператор должны быть одного типа, т.е.
писать вот так **нельзя**:
```cpp
auto val = condition ? "yes" : 0;
```
Более того, логично, если бы накладывалось требование на одинаковую категорию
value у возвращаемых типов.

### Счётчик в ```std::shared_ptr```

Я слышал два мнения:
+ Счётчик указателей на объект в ```std::shared_ptr``` является atomic.
+ ```std::shared_ptr``` сам по себе не очень хорошо ладит с многопоточностью.

[Уточнив](https://stackoverflow.com/questions/62784466/is-counter-in-stdshared-ptr-atomic),
стало понятно, что счётчик действительно atomic.
Получается, что копировать или делать ```move``` указателя 
в многопоточном приложении проблем не создаст, но стоит понимать, 
что сам объект, на который указывает ```std::shared_ptr```, никак от гонки за ресурсами
не защищён.

### ```using``` + ```template```
Можно писать вот так:
```cpp
template <typename T>
using mi = map<int, T>;
...
mi<string> map_from_int_to_string;
```

### Генерация имён для временных файлов

Для этих целей можно использовать [```std::tmpnam```](https://en.cppreference.com/w/cpp/io/c/tmpnam)
(правда оно немного небезопасно).

### Ускорение ```std::stack```

Известный факт, что ```std::stack``` является адаптером и по дефолту реализован на деке.
Это немного долговато. Чтобы ускорить, можно использовать в качестве базы ```std::vector```:
```cpp
std::stack<int, std::vector<int>> st;
```

### Ключ в ```std::map``` и ```std::unordered_map```

Ключ в ```std::map``` и ```std::unordered_map``` помечен как ```const```.
Вроде как это является интуитивным, потому что лично у меня никогда не возникало желания
изменять ключ в данных контейнерах, но есть и другая проблема, которая может возникнуть
из-за этого ограничения.

Предположим, что мы имеем
```cpp
std::map<MyType, other> mp;
```
и пробегаемся известной конструкцией с явным указанием типа пары:
```cpp
for (std::pair<MyType, other> x : mp) {}
```
Ни для кого не секрет, что тут будет копирование каждой пары.

Давайте рассмотрим вот такой код:
```cpp
for (const std::pair<MyType, other>& x : mp) {}
```
Вроде как мы всё исправили. 

А вот и нет!

В силу того, что ключ помечен ```const```, при получении по итератору пары из ```std::map```
будет произведён каст к указанному типу(а просто так скастовать не получится), 
что приведёт к лишнему копированию каждой пары.

Потому лучше всё-таки писать ```auto``` :)

### ```std::tie```

Это конечно довольно базовое знание, но кажется, лучше иногда напомнить.

Имеется вот такая структура:
```cpp
struct Student {
  std::string name;
  std::string surname;
  int year;
  int month;
  int day;
};
```

И мы хотим посортировать вектор таких чуваков в лексикографическом, заданном нами, порядке.

Вместо того, чтобы городить некрасивые конструкции из ифов, удобно сделать вот так:
```cpp
std::vector<Student> v;
...
std::sort(begin(v), end(v), [](auto l, auto r) {
  return std::tie(l.surname, l.name, l.year, l.month, l.day) < 
         std::tie(r.surname, r.name, r.year, r.month, r.day);
});
```

### Приоритет операторов

В целом неоднозначных случаев не возникает, но я встретил два момента, в которых
всё работает не так, как кажется.

1. Представим вот такой код:
```cpp
int* p = new int();
int* pp = new int();
delete p, pp;
```
Понятно, что ```pp``` не удалится! 
Ведь оператор ```delete``` является унарным и имеет приоритет выше, чем у 
оператора ```,```(запятая).

Если же написать:
```cpp
delete (p, pp);
```
то удалится только ```pp```, потому что оператор запятая возвращает последний операнд.

Решение выглядит так:
```cpp
delete p;
delete pp;
// or
delete p, delete pp; // но это какой-то говнокод :)
```

2. Вот такой код:
```cpp
int val;
...
if (val & 1 == 1) {
  ...
}
```
Тут интуитивно хотелось бы проверить последний бит числа ```val``` 
на равенство единице, но не получится:
приоритет оператора ```==``` выше, чем у ```&```(впрочем, как и у других
побитовых операторов).
Потому надо писать вот так:
```cpp
if ((val & 1) == 1) {
...
}
```

### ```static_cast```

Возможно вы думали, что можно кастовать типы с помощью ```static_cast``` 
только если они "одного рода"(например один числовой тип к другому).
На самом деле область шире.
Вы можете использовать его для приведения вот так:
```cpp
type1 a;
static_cast<type2>(a);
```
если можете писать вот так:
```cpp
type1 a;
type2 b = a;
```
Например:
```cpp
int x = 5;
auto v = static_cast<std::vector<int>>(x);
// now v = std::vector<int>{0, 0, 0, 0, 0}
```
Причём стоит понимать, что при таком касте создаётся копия объекта типа, к которому кастуют.

### Определение pure virtual function

```cpp
struct A {
    virtual ~A() = 0;
};

A::~A() {} // доопределяем

struct B : public A {
  ~B() {}  
};
...
A* b = new B();
delete b;
```
При удалении ```b``` будет вызван сначала деструктор ```B```, а потом ```A```,
но деструктор у ```A``` является pure virtual и мы получим ```undefined reference to A::~A()```,
потому его нужно всё равно определить.

Как по мне, очень необычно :)

### Проблема параметров по умолчанию при наследовании

```cpp
struct A {
  virtual void f(int x = 1) const {
    std::cout << "A: " << x << '\n';
  }
};

struct B : A {
  void f(int x = 2) const override {
    std::cout << "B: " << x << '\n';
  }
};
...
const A& a = B();
a.f(); // result "B: 1"
```
Проблема в том, что концепция значений по умолчанию разрешается в compile time,
в то время как выбор перегрузки функции в runtime. 
Потому компилятор подставит значение 1 для переменной ```x``` на этапе компиляции, 
а в runtime уже выберет версию с подставленным параметром.

### User-defined deduction guides(since C++17)

В C++17 появилась возможность автовывода шаблонных типов, когда это возможно:
```cpp
std::vector v{1, 2, 3};
```
Рассмотрим пример:
```cpp
template <typename T>
struct S {
  S(T x) {}
};
...
S s("abs");
```
Тут тип ```T``` будет выведен как ```const char*```, но можно попросить компилятор
в таких случаях выводить его как ```std::string```.
Для этого после класса пишем:
```cpp
S(const char*) -> S<std::string>;
```
Можно также писать шаблонные подсказки:
```cpp
template <typename T>
S(const T&) -> S<T&>;
```

### Function-try block

Можно писать вот так:
```cpp
void f() try {

} catch (...) {
}
```
Понятно, что почти всегда такая форма эквивалентна:
```cpp
void f() {
  try {
  } catch (...) {
  }
}
```
Однако есть ситуация, когда их поведение различно: исключение в списке инициализации конструктора:
```cpp
struct S {
  std::string s;
  
  S(const std::string& s) try : s(s) {
  } catch (...) {}
};
```
Таким образом мы защищаемся от исключений при вызове конструктора ```s(s)```
(понятно, что тут такого не возникнет, но с кастомными классами легко).

Также можно делать с циклами. Например
```cpp
while () try {
} catch (...) {}
```

### Перегрузка ```operator<<```

Довольно понятный, но неочевидный факт, что ```operator<<``` можно перегружать не только
для потоков и их наследников, но я для любых кастомных объектов:
```cpp
struct A {
    vector<int> a;
};

A& operator<<(A& a, int x) {
    a.a.push_back(x);
    return a;
}
...
A a;
a << 1 << 2 << 3;
for (int x : a.a) {
    cout << x << ' ';
}
```
Как результат получим вывод ```1 2 3```.

Так, например, сделан ```QStringList``` в Qt.

### Заметки о ```decltype```

1. Стоит помнить, что ```decltype``` не вычисляет значение выражения, которое ему "подсунули":
```cpp
int x = 0;
decltype(x++) y = x;
cout << x << ' ' << y; // 0 0
```

2. Есть также три правила, которые стоит учитывать при использовании ```decltype```:
```cpp
decltype(expr)
if expr is lvalue of type T, then decltype returns T&
if expr is prvalue of type T, then decltype returns T
if expr is xvalue of type T, then decltype returns T&&
```

3. Есть такой трюк для того, чтобы узнать, какой тип вывел ```decltype```:
```cpp
template <typename t>
class Check {
  Check() = delete;
};

int x;
Check<decltype(x)> check;
```
В ошибке компиляции мы явно увидим тип, который был выведен(в данном случае ```int```).

Также мы наше выражение можем обернуть в скобки:
```cpp
Check<decltype((x))> check;
```
Тут уже тип будет ```int&```.

Потому со скобками стоит бысть осторожными, т.к., например, в функциях с выводом возвращаемого типа,
поставив скобки вокруг возвращаемого в ```return``` значения можно всё сломать(существует такая практика).
```cpp
template <typename Container>
decltype(auto) get(Container& c, size_t i) {
  return (c[i]); // всегда будем получать тип с & 
}
```

### Возвращаемый тип ```throw```

Какой тип будет иметь переменная ```y``` в следующем случае?
```cpp
int x = 0;
decltype(throw 1)* y = &x;
```
Правильным ответом будет ```void*```, т.к. результат ```throw``` определён как ```void```.

### Зачем нужен ```std::invoke```

[```std::invoke```](https://en.cppreference.com/w/cpp/utility/functional/invoke) 
умеет осуществлять вызов функционального объекта.

Зачем это нужно, если все функциональные объекты можно вызвать с помощью ()?

На самом деле это не так, ведь синтаксис для вызова через указатель на метод класса или 
указатель на член класса отличается от стандартного.
Использование же данной  функции позволяет унифицировать этот процесс.

### Инициализация в if since C++17

В C++17 была добавлена возможность инициализировать переменную перед условием в
условных конструкциях. 

У многих возникает вопрос, зачем писать например вот так:
```cpp
if (bool x = f(); x) {...}
```
если можно вот так:
```cpp
if (bool x = f()) {...}
```
Действительно, во многих ситуациях код лучше не станет.
Однако при использовании чего-то вроде ```std::lock_guard``` это может быть удобно:
```cpp
if (std::lock_guard<std::mutex> guard(mutex); condition) {...}
else {...}
```
Мьютекс будет залочен до конца ифа в обеих ветках и одновременно с этим ```guard``` 
будет существовать в интересующей нас области видимости.

### Использование ```return *this``` в перегрузке операторов

Посмотрим, какие возможности даст нам подобный трюк:
```cpp
struct A {
  int x;
  
  A& operator/(int div) {
    x /= div;
    return *this;
  }
};

A a;
a.x = 100;
a / 2 / 2 / 5;
// now a.x = 5
```
Подобный способ используется например в ```boost::format```:
```cpp
boost::format("%1% %2% %3%") % s1 % s2 % s3;
```

### Удобная форма написания операторов копирования/перемещения

Есть вот такой удобный способ писать операторы копирования/перемещения:

```cpp
class A {
 public:
  A(const A& a) {...}
  A(A&& a) {...}
  ~A() {...}
  
  A& operator=(const A& a) {
    if (this == &a) {
      return *this;
    }
    this->~A(); // если без this, то будет ругаться, что мы пытаемся инвертировать конструктор
    new(this) A(a);
    return *this;
  }
  
  A& operator=(A&& a) {
    if (this == &a) {
      return *this;
    }
    this->~A();     
    new(this) A(std::move(a));
    return *this;
  }
};
```
Кто-то скажет, что использование объекта после вызова деструктора по стандарту это undefined behaviour,
но сам объект мы не используем, а используем его storage, 
а тут проблем с этим [нет](https://timsong-cpp.github.io/cppwp/n4659/basic.life#8).

### Простой способ написать итератор на вектор

В некоторых случаях при реализации итератора можно просто сделать ```typedef``` на указатель, 
как например сделано в libc++ clang(https://github.com/llvm-mirror/libcxx/blob/master/include/vector#L340).

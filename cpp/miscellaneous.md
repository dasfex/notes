## Содержание

0. Cpp optimizations.
1. Macros tricks.
2. Типы возвращаемых значений у тернарного оператора.
3. Счётчик в ```std::shared_ptr```.
4. Генерация имён для временных файлов.
5. Notes on ```std::map``` и ```std::unordered_map```.
6. ```std::tie```.
7. Приоритет операторов.
8. ```static_cast```.
9. Определение pure virtual function.
10. Проблема параметров по умолчанию при наследовании.
11. Function-try block.
12. Overload notes.
13. Возвращаемый тип ```throw```.
14. Зачем нужен ```std::invoke```.
15. Инициализация в if since C++17.
16. Удобная форма написания операторов копирования/перемещения.
17. Простой способ написать итератор на вектор.
18. Point of Declaration(PoD). 
19. Почему метод ```pop``` не возвращает значение в STL. 
20. Note on ```std::vector::push_back``` implementation.
21. Atomicity and static variables.
22. Реализовывать бинарные операторы всегда лучше вне класса.

### Cpp optimizations.

1. EBCO.

```cpp
struct base {};
struct der: base {
  int a;
};
```
Чему будет равен ```sizeof(der)```? 
Зная, как работает наследование, создание пустого типа и выравнивание,
можно предположить, что 8 байт.
Однако в таких случаях происходит *Empty Base Class Optimization*:
если родитель является пустым, то его часть не создаётся в наследниках.
Т.е. ```sizeof(der)``` равен 4.

Или например можно использовать вот так: [cppstories.com/2021/no-unique-address/](https://www.cppstories.com/2021/no-unique-address/).

2. Return Value Optimization.

3. [SSO](https://stackoverflow.com/questions/3770781/why-is-sizeofstring-32).

4. [Copy elision](https://en.m.wikipedia.org/wiki/Copy_elision).

### Macros tricks

##### Полезные макросы
Существует несколько макросов, с помощью которых можно узнавать
некоторую информацию о месте их вызова.
Это может может быть полезно при использовании различных макросов. 
Текущий файл(```__FILE__```) и текущая линия(```__LINE__```).
Очень удобно использовать в каких-либо макросах для получения
дополнительной информации. 
Например, в ```assert```:
```cpp
#define assert(expr)							\
   (static_cast<bool>(expr)						\
      ? void (0)							\
      : __assert_fail(#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
```

```__PRETTY_FUNCTION__``` позволяет узнать сигнатуру функции, в которой вызывается:
```cpp
void f(int) {
    cout << __PRETTY_FUNCTION__;
}
```
Как результат получим:
```cpp
void f(int)
```

```__COUNTER__``` позволяет получать последовательные значения
от 0. 
```cpp
std::cout << __COUNTER__ << __COUNTER__ << __COUNTER__;
```
Результат:
```
012
```

#### Анонимные переменные

Создание анонимной переменной может быть полезно при создании буферного объекта.
Например с ```gsl::finally```:
```cpp
#define CONCATENATE_IMPL(s1, s2) s1##s2
#define CONCATENATE(s1, s2) CONCATENATE_IMPL(s1, s2)

#ifdef __COUNTER__
#define ANONYMOUS_VARIABLE(str) CONCATENATE(str, __COUNTER__)
#else
#define ANONYMOUS_VARIABLE(str) CONCATENATE(str, __LINE__)
#endif

auto ANONYMOUS_VARIABLE(var) = gsl::finally([] {});
```
Это не анонимная в полном смысле этого слова переменная, т.к. её можно использовать, зная имя, но
теперь не нужно думать, какие имена использовать для нескольких переменных.

#### Использование ```do-while``` в макросах

Такой приём может быть полезен, чтобы заставить пользователя ставить ```;``` после вашего макроса:
```cpp
#define MY \
    do { \
      int x = 1; \
    } while (false)
```
А ещё это часто используют для того, что ввести новую область видимости и
не получать конфликтов с уже существующими именами. 

#### Использование конкатенации строк строк на компиляции

Думаю, вы тоже видели какой-то подобный код:

```cpp
std::string very_long_string = "This is first part of long string." "And this is second";
```
Никаких плюсов и функций конкатенации: компилятор сделает это одной строкой сам. Используя такое поведение можно реализовать интересный макрос:

```cpp
#define LOG(exp) std::cout << "Result of " #exp "=" << exp;
int x = 12;
LOG(x*5);
```

Результатом будет ```Result of x*5=60```.


### Типы возвращаеых значений у тернарного оператора

Это кажется очевидным, но стоит помнить, что оба значения/выражения,
которые возвращает тернарный оператор должны быть одного типа, т.е.
писать вот так **нельзя**:
```cpp
auto val = condition ? "yes" : 0;
```
Более того, логично, если бы накладывалось требование на одинаковую категорию
value у возвращаемых типов.

Хотя иногда это конечно мешает:
```cpp
std::optional<int> val = condition ? std::nullopt : 1;
```

### Счётчик в ```std::shared_ptr```

Я слышал два мнения:
+ Счётчик указателей на объект в ```std::shared_ptr``` является atomic.
+ ```std::shared_ptr``` сам по себе не очень хорошо ладит с многопоточностью.

[Уточнив](https://stackoverflow.com/questions/62784466/is-counter-in-stdshared-ptr-atomic),
стало понятно, что счётчик действительно atomic.
Получается, что копировать или делать ```move``` указателя 
в многопоточном приложении проблем не создаст, но стоит понимать, 
что сам объект, на который указывает ```std::shared_ptr```, никак от гонки за ресурсами
не защищён.

### Генерация имён для временных файлов

Для этих целей можно использовать [```std::tmpnam```](https://en.cppreference.com/w/cpp/io/c/tmpnam)
(правда оно немного небезопасно).

### Notes on ```std::map``` и ```std::unordered_map```

1. Ключ в ```std::map``` и ```std::unordered_map``` помечен как ```const```.
Вроде как это является интуитивным, потому что лично у меня никогда не возникало желания
изменять ключ в данных контейнерах, но есть и другая проблема, которая может возникнуть
из-за этого ограничения.

Предположим, что мы имеем
```cpp
std::map<MyType, other> mp;
```
и пробегаемся известной конструкцией с явным указанием типа пары:
```cpp
for (std::pair<MyType, other> x : mp) {}
```
Ни для кого не секрет, что тут будет копирование каждой пары.

Давайте рассмотрим вот такой код:
```cpp
for (const std::pair<MyType, other>& x : mp) {}
```
Вроде как мы всё исправили. 

А вот и нет!

В силу того, что ключ помечен ```const```, при получении по итератору пары из ```std::map```
будет произведён каст к указанному типу(а просто так скастовать не получится), 
что приведёт к лишнему копированию каждой пары.

Потому лучше всё-таки писать ```auto``` :)

2. Рассмотрим такую ситуацию:
```cpp
void f(int iters) {
  std::unordered_map<string, int> mp;
  const char key[] = "asdasdasdasd";
  while (--iters) mp.find(key);
}
```
Каждый раз, когда мы пытаемся найти ```key``` в ```mp```, 
в силу несовпадения типов создаётся объект типа ```string```.
Т.е. имеем одно лишнее копирование при каждом поиске. 
В случае ```std::map``` можно было бы использовать
гетерогенный поиск(heterogenious lookup), но у хеш-таблиц
стандартной библиотеки его нет, потому остаётся только поменять тип
искомого значения. 

3. 
```cpp
void f(int iters) {
  std::unordered_map<string, int> mp;
  std::pair<const string, int> p = {};
  while (--iters) mp.insert(key);
}
```
Тут при каждой вставке мы так же будем копировать
переданный объект, т.к. у ```insert``` есть всего 
2 перегрузки(для ```const value_type& value``` и ```value_type&& value```). 
Для исправления нужно сделать весь ```pair``` константым. 


```cpp
void f(int iters) {
  std::unordered_map<string, int> mp;
  const string key = "";
  while (--iters) mp.emplace(key, 0);
}
```
При вставке впервые всё пройдёт хорошо, но при последующих
на куче будет создана нода, контейнер попытается её вставить, у него не получится и 
он освободит место под ноду на куче. И это каждый раз. Исправить можно вот так:
```cpp
void f(int iters) {
  std::unordered_map<string, int> mp;
  const std::pair<const string, int> p = {};
  while (--iters) mp.insert(p);
}
```

### ```std::tie```

Это конечно довольно базовое знание, но лучше иногда напомнить.

Имеется вот такая структура:
```cpp
struct Student {
  std::string name;
  std::string surname;
  int year;
  int month;
  int day;
};
```

И мы хотим посортировать вектор таких чуваков в лексикографическом, заданном нами, порядке.

Вместо того, чтобы городить некрасивые конструкции из ифов, удобно сделать вот так:
```cpp
std::vector<Student> v;
...
std::sort(begin(v), end(v), [](auto l, auto r) {
  return std::tie(l.surname, l.name, l.year, l.month, l.day) < 
         std::tie(r.surname, r.name, r.year, r.month, r.day);
});
```

### Приоритет операторов

В целом неоднозначных случаев не возникает, но я встретил два момента, в которых
всё работает не так, как кажется.

1. Представим вот такой код:
```cpp
int* p = new int();
int* pp = new int();
delete p, pp;
```
Понятно, что ```pp``` не удалится! 
Ведь оператор ```delete``` является унарным и имеет приоритет выше, чем у 
оператора ```,```(запятая).

Если же написать:
```cpp
delete (p, pp);
```
то удалится только ```pp```, потому что оператор запятая возвращает последний операнд.

Потому пишем просто:
```cpp
delete p;
delete pp;
```

2. Вот такой код:
```cpp
int val;
...
if (val & 1 == 1) {
  ...
}
```
Тут интуитивно хотелось бы проверить последний бит числа ```val``` 
на равенство единице, но не получится:
приоритет оператора ```==``` выше, чем у ```&```(впрочем, как и у других
побитовых операторов).
Потому надо писать вот так:
```cpp
if ((val & 1) == 1) {
...
}
```

### ```static_cast```

Возможно вы думали, что можно кастовать типы с помощью ```static_cast``` 
только если они "одного рода"(например один числовой тип к другому).
На самом деле область шире.
Вы можете использовать его для приведения вот так:
```cpp
type1 a;
static_cast<type2>(a);
```
если можете писать вот так:
```cpp
type1 a;
type2 b(a);
```
Например:
```cpp
int x = 5;
auto v = static_cast<std::vector<int>>(x);
// now v = std::vector<int>{0, 0, 0, 0, 0}
```
Причём стоит понимать, что при таком касте создаётся копия объекта типа, к которому кастуют.

### Определение pure virtual function

```cpp
struct A {
    virtual ~A() = 0;
};

A::~A() {} // доопределяем

struct B : public A {
  ~B() {}  
};
...
A* b = new B();
delete b;
```
При удалении ```b``` будет вызван сначала деструктор ```B```, а потом ```A```,
но деструктор у ```A``` является pure virtual и мы получим ```undefined reference to A::~A()```,
потому его нужно всё равно определить.

Как по мне, очень необычно :)

### Проблема параметров по умолчанию при наследовании

```cpp
struct A {
  virtual void f(int x = 1) const {
    std::cout << "A: " << x << '\n';
  }
};

struct B : A {
  void f(int x = 2) const override {
    std::cout << "B: " << x << '\n';
  }
};
...
const A& a = B();
a.f(); // result "B: 1"
```
Проблема в том, что концепция значений по умолчанию разрешается в compile time,
в то время как выбор перегрузки функции в runtime. 
Потому компилятор подставит значение 1 для переменной ```x``` на этапе компиляции, 
а в runtime уже выберет версию с подставленным параметром.

### Function-try block

Можно писать вот так:
```cpp
void f() try {

} catch (...) {
}
```
Понятно, что почти всегда такая форма эквивалентна:
```cpp
void f() {
  try {
  } catch (...) {
  }
}
```
Однако есть ситуация, когда их поведение различно: исключение в списке инициализации конструктора:
```cpp
struct S {
  std::string s;
  
  S(const std::string& s) try : s(s) {
  } catch (...) {}
};
```
Таким образом мы защищаемся от исключений при вызове конструктора ```s(s)```
(понятно, что тут такого не возникнет, но с кастомными классами легко).

Также можно делать с циклами. Например
```cpp
while () try {
} catch (...) {}
```

### Overload notes

##### operator<<
Довольно понятный, но неочевидный факт, что ```operator<<``` можно перегружать не только
для потоков и их наследников, но и для любых кастомных объектов:
```cpp
struct A {
    vector<int> a;
};

A& operator<<(A& a, int x) {
    a.a.push_back(x);
    return a;
}
...
A a;
a << 1 << 2 << 3;
for (int x : a.a) {
    cout << x << ' ';
}
```
Как результат получим вывод ```1 2 3```.

Так, например, сделан ```QStringList``` в Qt.

##### Использование ```return *this``` в перегрузке операторов

Посмотрим, какие возможности даст нам такое решение:
```cpp
struct A {
  int x;
  
  A& operator/(int div) {
    x /= div;
    return *this;
  }
};

A a;
a.x = 100;
a / 2 / 2 / 5;
// now a.x = 5
```
Подобный способ используется например в ```boost::format```:
```cpp
boost::format("%1% %2% %3%") % s1 % s2 % s3;
```

### Возвращаемый тип ```throw```

Какой тип будет иметь переменная ```y``` в следующем случае?
```cpp
int x = 0;
decltype(throw 1)* y = &x;
```
Правильным ответом будет ```void*```, т.к. результат ```throw``` определён как ```void```.

### Зачем нужен ```std::invoke```

[```std::invoke```](https://en.cppreference.com/w/cpp/utility/functional/invoke) 
умеет осуществлять вызов функционального объекта.

Зачем это нужно, если все функциональные объекты можно вызвать с помощью ()?

На самом деле это не так, ведь синтаксис для вызова через указатель на метод класса или 
указатель на член класса отличается от стандартного.
Использование же данной  функции позволяет унифицировать этот процесс.

### Инициализация в if since C++17

В C++17 была добавлена возможность инициализировать переменную перед условием в
условных конструкциях. 

У многих возникает вопрос, зачем писать например вот так:
```cpp
if (bool x = f(); x) {...}
```
если можно вот так:
```cpp
if (bool x = f()) {...}
```
Действительно, во многих ситуациях код лучше не станет.
Однако при использовании чего-то вроде ```std::lock_guard``` это может быть удобно:
```cpp
if (std::lock_guard<std::mutex> guard(mutex); condition) {...}
else {...}
```
Мьютекс будет залочен до конца ифа в обеих ветках и одновременно с этим ```guard``` 
будет существовать в интересующей нас области видимости.

### Удобная форма написания операторов копирования/перемещения

Есть вот такой удобный способ писать операторы копирования/перемещения:

```cpp
class A {
 public:
  A(const A& a) {...}
  A(A&& a) {...}
  ~A() {...}
  
  A& operator=(const A& a) {
    if (this != &a) {
      this->~A(); // если без this, то будет ругаться, что мы пытаемся инвертировать конструктор
      new(this) A(a);
    }
    return *this;
  }
  
  A& operator=(A&& a) {
    if (this != &a) {
      this->~A();     
      new(this) A(std::move(a));
    }
    return *this;
  }
};
```
Кто-то скажет, что использование объекта после вызова деструктора по стандарту это undefined behaviour,
но сам объект мы не используем, а используем его storage, 
а тут проблем с этим [нет](https://timsong-cpp.github.io/cppwp/n4659/basic.life#8).

Однако применять такой способ нужно с осторожностью, ведь в случае, если при конструировании объекта 
в строке с ```placement new``` вылетит исключение, начнётся раскрутка стека, что повлечёт за собой вызов 
деструктора, однако раз объект был уничтожен, но ещё не создан, получил двойной вызов деструктора, 
что является ub. 

### Простой способ написать итератор на вектор

В некоторых случаях при реализации итератора можно просто сделать ```typedef``` на указатель, 
как например сделано в libc++ clang(https://github.com/llvm-mirror/libcxx/blob/master/include/vector#L340).

### Point of Declaration(PoD)

PoD - место, после которого имя объявленной переменной вводится в область видимости. 

Рассмотрим два примера:
```cpp
int y = 2; { int y = y; }
int x = 2; { int x[x]; }
```
В каком случае будет использовано значение из внешней области видимости, а в какой изнутри?

В 1м случае ```y``` будет инициализирован сам собой, а во второй ```x``` будет взят из внешней области видимости. 

В данном случае выглядеть всё будет вот так:
```cpp
int y = 2; { int y /* PoD */ = y; }
int x = 2; { int x[x] /* PoD */ ; }
```

Аналогично для классов и структур:
```cpp
template <class T>
struct Node /* PoD */ {
  T val;
  Node<T>* next;
};
```

Интересно, что можно опустить шаблон в типе поля ```next```, причём это никак не связано
с выводом типа. 
Просто компилятор уже всё знает про введённый тип и считает такую запись как обращение к самому себе:
```cpp
template <class T>
struct Node /* PoD */ {
  T val;
  Node* next;
};
```

### Почему метод ```pop``` не возвращает значение в STL

Рассмотрим такой код:
```cpp
template <typename T>
class Vector {
  T* arr_;
  size_t size_;
  size_t capacity_;
 public: 
  T pop() {
    assert(size_ > 0);
    T result = arr_[size_ - 1];
    --size_;
    return result;
  }
}

SomeType s = v.pop();
```
В самой функции ```pop``` всё корректно, но что если при копировании в ```s```
вылетит исключение? Получается, что объекта в векторе уже нет, но в точку
назначения он не пришёл. Получили утечку памяти и результата. 
Потому вся стандартная библиотека разделяет получение и удаление элемента. 

### Note on ```std::vector::push_back``` implementation.

На текущий момент, если требуется, ```push_back``` 
реаллоцирует память, перекладывает элементы
в новое место и конструирует новый объект.

Однако настоящий ```push_back``` делает ещё кое-что:
он сначала кладёт новый элемент на его место, а только потом
перекладывает остальные элементы, если требуется.

Зачем это нужно?

Что будет, если написать ```v.push_back(v.back())```?
Если так окажется, что при текущем добавлении нужно изменять capacity,
после всех перекладываний элементов в новое место ```v.back()```
окажется битой ссылкой на место в старом массиве.
Потому надо сначала сконструировать то, что попросили, а потом переложить.

### Atomicity and static variables
Мало кто знает, но с C++11 инициализация статической переменной 
обязана быть атомарной операцией. 
Потому надо аккуратно их применять. 

### Реализовывать бинарные операторы всегда лучше вне класса
Можно реализовывать бинарные операторы вот так:
```cpp
class A {
  A& operator+(const A& a) {...}
};
```
или вот так:
```cpp
class A {};

A* operator+(const A& lhs, const A& rhs) {...}
```
Лучше реализовывать вторым вариантом потому что
в таком случае к обоим операндам может сработать приведение типов, 
в то время как при реализации в классе только для правого операнда,
а к ```this``` нет. 
Очевидно, лучше создавать симметричные решения. 

## Содержание

0. Cpp optimizations.
1. Макросы ```__FILE__```, ```__LINE__```.
2. Типы возвращаемых значений у тернарного оператора.
3. Счётчик в ```std::shared_ptr```.
4. ```using``` + ```template```.
5. Генерация имён для временных файлов.
6. Ускорение ```std::stack```.
7. Ключ в ```std::map``` и ```std::unordered_map```.
8. ```std::tie```.
9. Приоритет операторов.
10. ```static_cast```.
11. Определение pure virtual function.
12. Проблема параметров по умолчанию при наследовании.
13. User-defined deduction guides(since C++17).
14. Function-try block.
15. Перегрузка ```operator<<```.
16. Argument dependent lookup(ADL).
17. Заметка о ```decltype``` и ```throw```.

### Cpp optimizations.

1. EBCO.

```cpp
struct base {};
struct der: base {
  int a;
};
```
Чему будет равен ```sizeof(der)```? 
Зная, как работает наследование, создание пустого типа и выравнивание,
можно предположить, что 8 байт.
Однако в таких случаях происходит *Empty Base Class Optimization*:
если родитель является пустым, то его часть не создаётся в наследниках.
Т.е. ```sizeof(der)``` равен 4.

2. Return Value Optimization.

3. [SSO](https://stackoverflow.com/questions/3770781/why-is-sizeofstring-32).

4. [Copy elision](https://en.m.wikipedia.org/wiki/Copy_elision).

### ```__FILE__```, ```__LINE__```

Существует два макроса, с помощью которых можно узнавать
текущий файл(```__FILE__```) и текущую линию(```__LINE__```).
Очень удобно использовать в каких-либо макросах для получения
дополнительной информации. 
Например, в ```assert```:
```cpp
#  define assert(expr)							\
     (static_cast <bool> (expr)						\
      ? void (0)							\
      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
```

### Типы у тернарного оператора

Это кажется очевидным, но стоит помнить, что оба значения/выражения,
которые возвращает тернарный оператор должны быть одного типа, т.е.
писать вот так **нельзя**:
```cpp
auto val = condition ? "yes" : 0;
```
Более того, логично, если бы накладывалось требование на одинаковую категорию
value у возвращаемых типов.

### Счётчик в ```std::shared_ptr```

Я слышал два мнения:
+ Счётчик указателей на объект в ```std::shared_ptr``` является atomic.
+ ```std::shared_ptr``` сам по себе не очень хорошо ладит с многопоточностью.

[Уточнив](https://stackoverflow.com/questions/62784466/is-counter-in-stdshared-ptr-atomic),
стало понятно, что счётчик действительно atomic.
Получается, что копировать или делать ```move``` указателя 
в многопоточном приложении проблем не создаст, но стоит понимать, 
что сам объект, на который указывает ```std::shared_ptr```, никак от гонки за ресурсами
не защищён.

### ```using``` + ```template```
Можно писать вот так:
```cpp
template <typename T>
using mi = map<int, T>;
...
mi<string> map_from_int_to_string;
```

### Генерация имён для временных файлов

Для этих целей можно использовать [```std::tmpnam```](https://en.cppreference.com/w/cpp/io/c/tmpnam)
(правда оно немного небезопасно).

### Ускорение ```std::stack```

Известный факт, что ```std::stack``` является адаптером и по дефолту реализован на деке.
Это немного долговато. Чтобы ускорить, можно использовать в качестве базы ```std::vector```:
```cpp
std::stack<int, std::vector<int>> st;
```

### Ключ в ```std::map``` и ```std::unordered_map```

Ключ в ```std::map``` и ```std::unordered_map``` помечен как ```const```.
Вроде как это является интуитивным, потому что лично у меня никогда не возникало желания
изменять ключ в данных контейнерах, но есть и другая проблема, которая может возникнуть
из-за этого ограничения.

Предположим, что мы имеем
```cpp
std::map<MyType, other> mp;
```
и пробегаемся известной конструкцией с явным указанием типа пары:
```cpp
for (std::pair<MyType, other> x : mp) {}
```
Ни для кого не секрет, что тут будет копирование каждой пары.

Давайте рассмотрим вот такой код:
```cpp
for (const std::pair<MyType, other>& x : mp) {}
```
Вроде как мы всё исправили. 

А вот и нет!

В силу того, что ключ помечен ```const```, при получении по итератору пары из ```std::map```
будет произведён каст к указанному типу(а просто так скастовать не получится), 
что приведёт к лишнему копированию каждой пары.

Потому лучше всё-таки писать ```auto``` :)

### ```std::tie```

Это конечно довольно базовое знание, но кажется, лучше иногда напомнить.

Имеется вот такая структура:
```cpp
struct Student {
  std::string name;
  std::string surname;
  int year;
  int month;
  int day;
};
```

И мы хотим посортировать вектор таких чуваков в лексикографическом, заданном нами, порядке.

Вместо того, чтобы городить некрасивые конструкции из ифов, удобно сделать вот так:
```cpp
std::vector<Student> v;
...
std::sort(begin(v), end(v), [](auto l, auto r) {
  return std::tie(l.surname, l.name, l.year, l.month, l.day) < 
         std::tie(r.surname, r.name, r.year, r.month, r.day);
});
```

### Приоритет операторов

В целом неоднозначных случаев не возникает, но я встретил два момента, в которых
всё работает не так, как кажется.

1. Представим вот такой код:
```cpp
int* p = new int();
int* pp = new int();
delete p, pp;
```
Понятно, что ```pp``` не удалится! 
Ведь оператор ```delete``` является унарным и имеет приоритет выше, чем у 
оператора ```,```(запятая).

Если же написать:
```cpp
delete (p, pp);
```
то удалится только ```pp```, потому что оператор запятая возвращает последний операнд.

Решение выглядит так:
```cpp
delete p;
delete pp;
// or
delete p, delete pp; // но это какой-то говнокод :)
```

2. Вот такой код:
```cpp
int val;
...
if (val & 1 == 1) {
  ...
}
```
Тут интуитивно хотелось бы проверить последний бит числа ```val``` 
на равенство единице, но не получится:
приоритет оператора ```==``` выше, чем у ```&```(впрочем, как и у других
побитовых операторов).
Потому надо писать вот так:
```cpp
if ((val & 1) == 1) {
...
}
```

### ```static_cast```

Возможно вы думали, что можно кастовать типы с помощью ```static_cast``` 
только если они "одного рода"(например один числовой тип к другому).
На самом деле область шире.
Вы можете использовать его для приведения вот так:
```cpp
type1 a;
static_cast<type2>(a);
```
если можете писать вот так:
```cpp
type1 a;
type2 b = a;
```
Например:
```cpp
int x = 5;
auto v = static_cast<std::vector<int>>(x);
// now v = std::vector<int>{0, 0, 0, 0, 0}
```
Причём стоит понимать, что при таком касте создаётся копия объекта типа, к которому кастуют.

### Определение pure virtual function

```cpp
struct A {
    virtual ~A() = 0;
};

A::~A() {} // доопределяем

struct B : public A {
  ~B() {}  
};
...
A* b = new B();
delete b;
```
При удалении ```b``` будет вызван сначала деструктор ```B```, а потом ```A```,
но деструктор у ```A``` является pure virtual и мы получим ```undefined reference to A::~A()```,
потому его нужно всё равно определить.

Как по мне, очень необычно :)

### Проблема параметров по умолчанию при наследовании

```cpp
struct A {
  virtual void f(int x = 1) const {
    std::cout << "A: " << x << '\n';
  }
};

struct B : A {
  void f(int x = 2) const override {
    std::cout << "B: " << x << '\n';
  }
};
...
const A& a = B();
a.f(); // result "B: 1"
```
Проблема в том, что концепция значений по умолчанию разрешается в compile time,
в то время как выбор перегрузки функции в runtime. 
Потому компилятор подставит значение 1 для переменной ```x``` на этапе компиляции, 
а в runtime уже выберет версию с подставленным параметром.

### User-defined deduction guides(since C++17)

В C++17 появилась возможность автовывода шаблонных типов, когда это возможно:
```cpp
std::vector v{1, 2, 3};
```
Рассмотрим пример:
```cpp
template <typename T>
struct S {
  S(T x) {}
};
...
S s("abs");
```
Тут тип ```T``` будет выведен как ```const char*```, но можно попросить компилятор
в таких случаях выводить его как ```std::string```.
Для этого после класса пишем:
```cpp
S(const char*) -> S<std::string>;
```
Можно также писать шаблонные подсказки:
```cpp
template <typename T>
S(const T&) -> S<T&>;
```

### Function-try block

Можно писать вот так:
```cpp
void f() try {

} catch (...) {
}
```
Понятно, что почти всегда такая форма эквивалентна:
```cpp
void f() {
  try {
  } catch (...) {
  }
}
```
Однако есть ситуация, когда их поведение различно: исключение в списке инициализации конструктора:
```cpp
struct S {
  std::string s;
  
  S(const std::string& s) try : s(s) {
  } catch (...) {}
};
```
Таким образом мы защищаемся от исключений при вызове конструктора ```s(s)```
(понятно, что тут такого не возникнет, но с кастомными классами легко).

Также можно делать с циклами. Например
```cpp
while () try {
} catch (...) {}
```

### Перегрузка ```operator<<```

Довольно понятный, но неочевидный факт, что ```operator<<``` можно перегружать не только
для потоков и их наследников, но я для любых кастомных объектов:
```cpp
struct A {
    vector<int> a;
};

A& operator<<(A& a, int x) {
    a.a.push_back(x);
    return a;
}
...
A a;
a << 1 << 2 << 3;
for (int x : a.a) {
    cout << x << ' ';
}
```
Как результат получим вывод ```1 2 3```.

Так, например, сделан ```QStringList``` в Qt.

### Argument dependent lookup

Рассмотрим следующий код:
```cpp
namespace A {
  struct S {};
  
  void call(const S& x) {}
}
...
A::S x;
call(x);
```
Удивительно, но этот код скомпилируется, несмотря на то, что мы явно не указали
namespace функции ```call```.
Это называется ```argument dependency looking```.
Компилятор смотрит на пространства имён аргументов и в них ищет функцию.

Что же будет, если подходящих вариантов несколько?
```cpp
namespace A {
    struct S1;
}

namespace B {
    struct S2 {};
    
    void call(const A::S1& x, const S2& y) {
        cout << "1";
    }
}

namespace A {
    struct S1 {};
    
    void call(const S1& x, const B::S2& y) {
        cout << "2";
    }
}
...
A::S1 x;
B::S2 y;
call(x, y);
```
Как вариант, вызовется та версия, которая раньше будет найдена(какой аргумент раньше объявлен).
Однако получим ошибку компиляции об неоднозначности вызова:
```
error: call of overloaded ‘call(A::S1&, B::S2&)’ is ambiguous
```
Существуют также ситуации, когда ADL не работает:
```cpp
void foo();
namespace N {
  struct X {};
  void foo(X) {};
  void qux(X) {};
}

struct C {
  void foo() {}
  void bar () {
    foo(N::X{}); // будет обнаружена C::foo, которая не принимает аргументы
  }
};

void bar() {
  extern void foo(); // redeclare ::foo
  foo(N::X{}); // ::foo не требует аргументов
}

int qux;

void baz() {
  qux(N::X{}); // variable declaration disables ADL for "qux"
}
```

### Заметка о ```decltype``` и ```throw```

1. Стоит помнить, что ```decltype``` не вычисляет значение выражения, которое ему "подсунули":
```cpp
int x = 0;
decltype(x++) y = x;
cout << x << ' ' << y; // 0 0
```

2. Какой тип будет иметь переменная ```y``` в следующем случае?
```cpp
int x = 0;
decltype(throw 1)* y = &x;
```
Правильным ответом будет ```void*```, т.к. результат ```throw``` определён как ```void```.


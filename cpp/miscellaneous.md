## Содержание

0. Cpp optimizations.
1. Макросы ```__FILE__```, ```__LINE__```, ```__COUNTER__```, ```__PRETTY_FUNCTION__```.
2. Типы возвращаемых значений у тернарного оператора.
3. Счётчик в ```std::shared_ptr```.
4. ```using``` + ```template```.
5. Генерация имён для временных файлов.
6. Ускорение ```std::stack```.
7. Заметки про ```std::map``` и ```std::unordered_map```.
8. ```std::tie```.
9. Приоритет операторов.
10. ```static_cast```.
11. Определение pure virtual function.
12. Проблема параметров по умолчанию при наследовании.
13. User-defined deduction guides(since C++17).
14. Function-try block.
15. Перегрузка ```operator<<```.
16. Заметки о ```decltype```.
17. Возвращаемый тип ```throw```.
18. Зачем нужен ```std::invoke```.
19. Инициализация в if since C++17.
20. Использование ```return *this``` в перегрузке операторов.
21. Удобная форма написания операторов копирования/перемещения.
22. Простой способ написать итератор на вектор.
23. Point of Declaration(PoD). 
24. Анонимные переменные. 
25. Использование ```do-while``` в макросах.  

### Cpp optimizations.

1. EBCO.

```cpp
struct base {};
struct der: base {
  int a;
};
```
Чему будет равен ```sizeof(der)```? 
Зная, как работает наследование, создание пустого типа и выравнивание,
можно предположить, что 8 байт.
Однако в таких случаях происходит *Empty Base Class Optimization*:
если родитель является пустым, то его часть не создаётся в наследниках.
Т.е. ```sizeof(der)``` равен 4.

Или например можно использовать вот так: [cppstories.com/2021/no-unique-address/](https://www.cppstories.com/2021/no-unique-address/).

2. Return Value Optimization.

3. [SSO](https://stackoverflow.com/questions/3770781/why-is-sizeofstring-32).

4. [Copy elision](https://en.m.wikipedia.org/wiki/Copy_elision).

### ```__FILE__```, ```__LINE__```, ```__COUNTER__```, ```__PRETTY_FUNCTION__```

Существует несколько макросов, с помощью которых можно узнавать
некоторую информацию о месте их вызова.
Это может может быть полезно при использовании различных макросов. 
Текущий файл(```__FILE__```) и текущая линия(```__LINE__```).
Очень удобно использовать в каких-либо макросах для получения
дополнительной информации. 
Например, в ```assert```:
```cpp
#define assert(expr)							\
   (static_cast<bool>(expr)						\
      ? void (0)							\
      : __assert_fail(#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
```

```__PRETTY_FUNCTION__``` позволяет узнать сигнатуру функции, в которой вызывается:
```cpp
void f(int) {
    cout << __PRETTY_FUNCTION__;
}
```
Как результат получим:
```cpp
void f(int)
```

```__COUNTER__``` позволяет получать последовательные значения
от 0. 
```cpp
std::cout << __COUNTER__ << __COUNTER__ << __COUNTER__;
```
Результат:
```
012
```

### Типы у тернарного оператора

Это кажется очевидным, но стоит помнить, что оба значения/выражения,
которые возвращает тернарный оператор должны быть одного типа, т.е.
писать вот так **нельзя**:
```cpp
auto val = condition ? "yes" : 0;
```
Более того, логично, если бы накладывалось требование на одинаковую категорию
value у возвращаемых типов.

### Счётчик в ```std::shared_ptr```

Я слышал два мнения:
+ Счётчик указателей на объект в ```std::shared_ptr``` является atomic.
+ ```std::shared_ptr``` сам по себе не очень хорошо ладит с многопоточностью.

[Уточнив](https://stackoverflow.com/questions/62784466/is-counter-in-stdshared-ptr-atomic),
стало понятно, что счётчик действительно atomic.
Получается, что копировать или делать ```move``` указателя 
в многопоточном приложении проблем не создаст, но стоит понимать, 
что сам объект, на который указывает ```std::shared_ptr```, никак от гонки за ресурсами
не защищён.

### ```using``` + ```template```
Можно писать вот так:
```cpp
template <typename T>
using mi = map<int, T>;
...
mi<string> map_from_int_to_string;
```

### Генерация имён для временных файлов

Для этих целей можно использовать [```std::tmpnam```](https://en.cppreference.com/w/cpp/io/c/tmpnam)
(правда оно немного небезопасно).

### Ускорение ```std::stack```

Известный факт, что ```std::stack``` является адаптером и по дефолту реализован на деке.
Это немного долговато. Чтобы ускорить, можно использовать в качестве базы ```std::vector```:
```cpp
std::stack<int, std::vector<int>> st;
```

### Заметки про ```std::map``` и ```std::unordered_map```

1. Ключ в ```std::map``` и ```std::unordered_map``` помечен как ```const```.
Вроде как это является интуитивным, потому что лично у меня никогда не возникало желания
изменять ключ в данных контейнерах, но есть и другая проблема, которая может возникнуть
из-за этого ограничения.

Предположим, что мы имеем
```cpp
std::map<MyType, other> mp;
```
и пробегаемся известной конструкцией с явным указанием типа пары:
```cpp
for (std::pair<MyType, other> x : mp) {}
```
Ни для кого не секрет, что тут будет копирование каждой пары.

Давайте рассмотрим вот такой код:
```cpp
for (const std::pair<MyType, other>& x : mp) {}
```
Вроде как мы всё исправили. 

А вот и нет!

В силу того, что ключ помечен ```const```, при получении по итератору пары из ```std::map```
будет произведён каст к указанному типу(а просто так скастовать не получится), 
что приведёт к лишнему копированию каждой пары.

Потому лучше всё-таки писать ```auto``` :)

2. Рассмотрим такую ситуацию:
```cpp
void f(int iters) {
  std::unordered_map<string, int> mp;
  const char key[] = "asdasdasdasd";
  while (--iters) mp.find(key);
}
```
Каждый раз, когда мы пытаемся найти ```key``` в ```mp```, 
в силу несовпадения типов создаётся объект типа ```string```.
Т.е. имеем одно лишнее копирование при каждом поиске. 
В случае ```std::map``` можно было бы использовать
гетерогенный поиск(heterogenious lookup), но у хеш-таблиц
стандартной библиотеки его нет, потому остаётся только поменять тип
искомого значения. 

3. 
```cpp
void f(int iters) {
  std::unordered_map<string, int> mp;
  std::pair<const string, int> p = {};
  while (--iters) mp.insert(key);
}
```
Тут при каждой вставке мы так же будем копировать
переданный объект, т.к. у ```insert``` есть всего 
2 перегрузки(для ```const value_type& value``` и ```value_type&& value```). 
Для исправления нужно сделать весь ```pair``` константым. 


```cpp
void f(int iters) {
  std::unordered_map<string, int> mp;
  const string key = "";
  while (--iters) mp.emplace(key, 0);
}
```
При вставке впервые всё пройдёт хорошо, но при последующих
на куче будет создана нода, контейнер попытается её вставить, у него не получится и 
он освободит место под ноду на куче. И это каждый раз. Исправить можно вот так:
```cpp
void f(int iters) {
  std::unordered_map<string, int> mp;
  const std::pair<const string, int> p = {};
  while (--iters) mp.insert(p);
}
```

### ```std::tie```

Это конечно довольно базовое знание, но кажется, лучше иногда напомнить.

Имеется вот такая структура:
```cpp
struct Student {
  std::string name;
  std::string surname;
  int year;
  int month;
  int day;
};
```

И мы хотим посортировать вектор таких чуваков в лексикографическом, заданном нами, порядке.

Вместо того, чтобы городить некрасивые конструкции из ифов, удобно сделать вот так:
```cpp
std::vector<Student> v;
...
std::sort(begin(v), end(v), [](auto l, auto r) {
  return std::tie(l.surname, l.name, l.year, l.month, l.day) < 
         std::tie(r.surname, r.name, r.year, r.month, r.day);
});
```

### Приоритет операторов

В целом неоднозначных случаев не возникает, но я встретил два момента, в которых
всё работает не так, как кажется.

1. Представим вот такой код:
```cpp
int* p = new int();
int* pp = new int();
delete p, pp;
```
Понятно, что ```pp``` не удалится! 
Ведь оператор ```delete``` является унарным и имеет приоритет выше, чем у 
оператора ```,```(запятая).

Если же написать:
```cpp
delete (p, pp);
```
то удалится только ```pp```, потому что оператор запятая возвращает последний операнд.

Решение выглядит так:
```cpp
delete p;
delete pp;
// or
delete p, delete pp; // но это какой-то говнокод :)
```

2. Вот такой код:
```cpp
int val;
...
if (val & 1 == 1) {
  ...
}
```
Тут интуитивно хотелось бы проверить последний бит числа ```val``` 
на равенство единице, но не получится:
приоритет оператора ```==``` выше, чем у ```&```(впрочем, как и у других
побитовых операторов).
Потому надо писать вот так:
```cpp
if ((val & 1) == 1) {
...
}
```

### ```static_cast```

Возможно вы думали, что можно кастовать типы с помощью ```static_cast``` 
только если они "одного рода"(например один числовой тип к другому).
На самом деле область шире.
Вы можете использовать его для приведения вот так:
```cpp
type1 a;
static_cast<type2>(a);
```
если можете писать вот так:
```cpp
type1 a;
type2 b = a;
```
Например:
```cpp
int x = 5;
auto v = static_cast<std::vector<int>>(x);
// now v = std::vector<int>{0, 0, 0, 0, 0}
```
Причём стоит понимать, что при таком касте создаётся копия объекта типа, к которому кастуют.

### Определение pure virtual function

```cpp
struct A {
    virtual ~A() = 0;
};

A::~A() {} // доопределяем

struct B : public A {
  ~B() {}  
};
...
A* b = new B();
delete b;
```
При удалении ```b``` будет вызван сначала деструктор ```B```, а потом ```A```,
но деструктор у ```A``` является pure virtual и мы получим ```undefined reference to A::~A()```,
потому его нужно всё равно определить.

Как по мне, очень необычно :)

### Проблема параметров по умолчанию при наследовании

```cpp
struct A {
  virtual void f(int x = 1) const {
    std::cout << "A: " << x << '\n';
  }
};

struct B : A {
  void f(int x = 2) const override {
    std::cout << "B: " << x << '\n';
  }
};
...
const A& a = B();
a.f(); // result "B: 1"
```
Проблема в том, что концепция значений по умолчанию разрешается в compile time,
в то время как выбор перегрузки функции в runtime. 
Потому компилятор подставит значение 1 для переменной ```x``` на этапе компиляции, 
а в runtime уже выберет версию с подставленным параметром.

### User-defined deduction guides(since C++17)

В C++17 появилась возможность автовывода шаблонных типов, когда это возможно:
```cpp
std::vector v{1, 2, 3};
```
Рассмотрим пример:
```cpp
template <typename T>
struct S {
  S(T x) {}
};
...
S s("abs");
```
Тут тип ```T``` будет выведен как ```const char*```, но можно попросить компилятор
в таких случаях выводить его как ```std::string```.
Для этого после класса пишем:
```cpp
S(const char*) -> S<std::string>;
```
Можно также писать шаблонные подсказки:
```cpp
template <typename T>
S(const T&) -> S<T&>;
```

### Function-try block

Можно писать вот так:
```cpp
void f() try {

} catch (...) {
}
```
Понятно, что почти всегда такая форма эквивалентна:
```cpp
void f() {
  try {
  } catch (...) {
  }
}
```
Однако есть ситуация, когда их поведение различно: исключение в списке инициализации конструктора:
```cpp
struct S {
  std::string s;
  
  S(const std::string& s) try : s(s) {
  } catch (...) {}
};
```
Таким образом мы защищаемся от исключений при вызове конструктора ```s(s)```
(понятно, что тут такого не возникнет, но с кастомными классами легко).

Также можно делать с циклами. Например
```cpp
while () try {
} catch (...) {}
```

### Перегрузка ```operator<<```

Довольно понятный, но неочевидный факт, что ```operator<<``` можно перегружать не только
для потоков и их наследников, но я для любых кастомных объектов:
```cpp
struct A {
    vector<int> a;
};

A& operator<<(A& a, int x) {
    a.a.push_back(x);
    return a;
}
...
A a;
a << 1 << 2 << 3;
for (int x : a.a) {
    cout << x << ' ';
}
```
Как результат получим вывод ```1 2 3```.

Так, например, сделан ```QStringList``` в Qt.

### Заметки о ```decltype```

1. Стоит помнить, что ```decltype``` не вычисляет значение выражения, которое ему "подсунули":
```cpp
int x = 0;
decltype(x++) y = x;
cout << x << ' ' << y; // 0 0
```

2. Есть также три правила, которые стоит учитывать при использовании ```decltype```:
```cpp
decltype(expr)
if expr is lvalue of type T, then decltype returns T&
if expr is prvalue of type T, then decltype returns T
if expr is xvalue of type T, then decltype returns T&&
```

3. Есть такой трюк для того, чтобы узнать, какой тип вывел ```decltype```:
```cpp
template <typename t>
class Check {
  Check() = delete;
};

int x;
Check<decltype(x)> check;
```
В ошибке компиляции мы явно увидим тип, который был выведен(в данном случае ```int```).

Также мы наше выражение можем обернуть в скобки:
```cpp
Check<decltype((x))> check;
```
Тут уже тип будет ```int&```.

Потому со скобками стоит бысть осторожными, т.к., например, в функциях с выводом возвращаемого типа,
поставив скобки вокруг возвращаемого в ```return``` значения можно всё сломать(существует такая практика).
```cpp
template <typename Container>
decltype(auto) get(Container& c, size_t i) {
  return (c[i]); // всегда будем получать тип с & 
}
```

### Возвращаемый тип ```throw```

Какой тип будет иметь переменная ```y``` в следующем случае?
```cpp
int x = 0;
decltype(throw 1)* y = &x;
```
Правильным ответом будет ```void*```, т.к. результат ```throw``` определён как ```void```.

### Зачем нужен ```std::invoke```

[```std::invoke```](https://en.cppreference.com/w/cpp/utility/functional/invoke) 
умеет осуществлять вызов функционального объекта.

Зачем это нужно, если все функциональные объекты можно вызвать с помощью ()?

На самом деле это не так, ведь синтаксис для вызова через указатель на метод класса или 
указатель на член класса отличается от стандартного.
Использование же данной  функции позволяет унифицировать этот процесс.

### Инициализация в if since C++17

В C++17 была добавлена возможность инициализировать переменную перед условием в
условных конструкциях. 

У многих возникает вопрос, зачем писать например вот так:
```cpp
if (bool x = f(); x) {...}
```
если можно вот так:
```cpp
if (bool x = f()) {...}
```
Действительно, во многих ситуациях код лучше не станет.
Однако при использовании чего-то вроде ```std::lock_guard``` это может быть удобно:
```cpp
if (std::lock_guard<std::mutex> guard(mutex); condition) {...}
else {...}
```
Мьютекс будет залочен до конца ифа в обеих ветках и одновременно с этим ```guard``` 
будет существовать в интересующей нас области видимости.

### Использование ```return *this``` в перегрузке операторов

Посмотрим, какие возможности даст нам подобный трюк:
```cpp
struct A {
  int x;
  
  A& operator/(int div) {
    x /= div;
    return *this;
  }
};

A a;
a.x = 100;
a / 2 / 2 / 5;
// now a.x = 5
```
Подобный способ используется например в ```boost::format```:
```cpp
boost::format("%1% %2% %3%") % s1 % s2 % s3;
```

### Удобная форма написания операторов копирования/перемещения

Есть вот такой удобный способ писать операторы копирования/перемещения:

```cpp
class A {
 public:
  A(const A& a) {...}
  A(A&& a) {...}
  ~A() {...}
  
  A& operator=(const A& a) {
    if (this != &a) {
      this->~A(); // если без this, то будет ругаться, что мы пытаемся инвертировать конструктор
      new(this) A(a);
    }
    return *this;
  }
  
  A& operator=(A&& a) {
    if (this != &a) {
      this->~A();     
      new(this) A(std::move(a));
    }
    return *this;
  }
};
```
Кто-то скажет, что использование объекта после вызова деструктора по стандарту это undefined behaviour,
но сам объект мы не используем, а используем его storage, 
а тут проблем с этим [нет](https://timsong-cpp.github.io/cppwp/n4659/basic.life#8).

Однако применять такой способ нужно с осторожностью, ведь в случае, если при конструировании объекта 
в строке с ```placement new``` вылетит исключение, начнётся раскрутка стека, что повлечёт за собой вызов 
деструктора, однако раз объект был уничтожен, но ещё не создан, получил двойной вызов деструктора, 
что является ub. 

### Простой способ написать итератор на вектор

В некоторых случаях при реализации итератора можно просто сделать ```typedef``` на указатель, 
как например сделано в libc++ clang(https://github.com/llvm-mirror/libcxx/blob/master/include/vector#L340).

### Point of Declaration(PoD)

PoD - место, после которого имя объявленной переменной вводится в область видимости. 

Рассмотрим два примера:
```cpp
int y = 2; { int y = y; }
int x = 2; { int x[x]; }
```
В каком случае будет использовано значение из внешней области видимости, а в какой изнутри?

В 1м случае ```y``` будет инициализирован сам собой, а во второй ```x``` будет взят из внешней области видимости. 

В данном случае выглядеть всё будет вот так:
```cpp
int y = 2; { int y /* PoD */ = y; }
int x = 2; { int x[x] /* PoD */ ; }
```

Аналогично для классов и структур:
```cpp
template <class T>
struct Node /* PoD */ {
  T val;
  Node<T>* next;
};
```

Интересно, что можно опустить шаблон в типе поля ```next```, причём это никак не связано
с выводом типа. 
Просто компилятор уже всё знает про введённый тип и считает такую запись как обращение к самому себе:
```cpp
template <class T>
struct Node /* PoD */ {
  T val;
  Node* next;
};
```

### Анонимные переменные

Создание анонимной переменной может быть полезно при создании буферного объекта. 
Например с ```gsl::finally```:
```cpp
#define CONCATENATE_IMPL(s1, s2) s1##s2
#define CONCATENATE(s1, s2) CONCATENATE_IMPL(s1, s2)

#ifdef __COUNTER__
#define ANONYMOUS_VARIABLE(str) CONCATENATE(str, __COUNTER__)
#else
#define ANONYMOUS_VARIABLE(str) CONCATENATE(str, __LINE__)
#endif

auto ANONYMOUS_VARIABLE(var) = gsl::finally([] {});
```
Это не анонимная в полном смысле этого слова переменная, т.к. её можно использовать, зная имя, но
теперь не нужно думать, какие имена использовать для нескольких переменных. 

### Использование ```do-while``` в макросах

Такой приём может быть полезен, чтобы заставить пользователя ставить ```;``` после вашего макроса:
```cpp
#define MY \
    do { \
      int x = 1; \
    } while (false)
```

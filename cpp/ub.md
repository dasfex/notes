# Undefined behaviour(неопределённое поведение)

Неопределённое поведение — поведение, которое может возникать 
в результате использования ошибочных программных конструкций или некорректных данных, 
на которые Международный Стандарт не налагает никаких требований. 
Неопределенное поведение также может возникать в ситуациях, не описанных в Стандарте явно.

Тут я попробую собрать примеры очевидного(и не очень) неопределённого поведения в C++.

### Захват переменных в лямбда-функции

Давайте представим вот такую ситуацию:
```cpp
class Div {
  int divisor;
  
 public:
  Div(int div) : divisor(div) {}

  auto get() {
    return [&](int n) {return n % divisor;};
  }
};
...
auto f = Div(10).get();
auto res = f(12);
```

Получаем ub.
Кажется, что тут очевидна проблема(захват переменных по ссылке).
Давайте исправим:
```cpp
...
auto get() {
  return [=](int n) {return n % divisor;};
}
... 
```

Вроде как всё исправили.
Однако тут тоже ub.

Почему же?

Потому что время жизни переменной(```divisor```) меньше, чем время жизни лямбда-функции.

Вы скажете, что мы же захватили её по значению!
Но это неправда, ведь члены класса не захватываются лямбдой.
В таких случаях захватываются лишь значения в локальной области видимости функции,
потому при вызове ```f(12)``` ```divisor``` скорее всего не существует, что и ведёт к ub.

Поправить это можно вот так:
```cpp
...
auto get() {
return [divisor = divisor](int n) {return n % divisor;};
}
...
```

Также стоит помнить про неявный захват ```*this```.

Ну и вообще вот 
[тут](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f53-avoid-capturing-by-reference-in-lambdas-that-will-be-used-non-locally-including-returned-stored-on-the-heap-or-passed-to-another-thread) 
можно почитать.

### Ub при знаковом переполнении

Можно почитать вот [тут](https://codeforces.com/blog/entry/45144).

### Dangling reference

Возврат ссылки на несуществующй объект:
```cpp
int& f(int x) {
  int y = x + 1;
  return y;
}
```
### reinterpret_cast

Его конечно не надо юзать, но всё же факт есть факт.

Предположим у нас есть ```double``` и мы хотим трактовать первых 4 его байта как ```int```:
```cpp
double x = 123.2312;
std::cout << reinterpret_cast<int>(x);
```
Однако так не скомпилируется, т.к. мы не создаём новый объект, мы просто хотим посмотреть 
на существующий под другим углом.
Потому надо кастить к ```int&```:
```cpp
std::cout << reinterpret_cast<int&>(x);
```

Можно ещё вот так:
```cpp
int* p = reinterpret_cast<int*&>(x);
```
Так мы посмотрим на все 8 байт.

Прикольно конечно, но это всё ub :)

### Инициализация переменных во вложенных скоупах

```cpp
string s = "123";
{
  string s = s;
}
```
Можно подумать, что вторая переменная ```s``` будет инициализирована первой, но 
она будет пытаться инициализироваться самой собой.
Причём это очевидно ub, т.к. вы пытаетесь инициализировать объект из ещё несозданного.

### Неопределённый порядок выполнения

Стоит быть аккуратным с выражениями вида:
```cpp
i = i++ + i++;
```
Потому что тут и правда неопределён порядок выполнения операций.

### Выход указателя за границы массива

Можно почитать вот [тут](https://stackoverflow.com/questions/10473573/why-is-out-of-bounds-pointer-arithmetic-undefined-behaviour).

### Incorrect printf use

```cpp
printf("%d%", double(5));
```
Результат такого выражения не определён и зависит от платформы.

Объяснение: [belaycpp.com/2021/08/31/yet-another-reason-to-not-use-printf-or-write-c-code-in-general/](https://belaycpp.com/2021/08/31/yet-another-reason-to-not-use-printf-or-write-c-code-in-general/).

### Неверная перегрузка операторов

Рассмотрим простой пример, когда неверно перегружен оператор ```<```:
```cpp
bool operator<(A& rhs, A& lhs) {
  return rhs.val <= lhs.val;
}
```
Подобная ситуация может привести к неопределённому поведению(например при использовании в сортировке), 
т.к. не соблюдается транзитивность операции(
если ```a < b``` и ```b < c```, то должно быть и ```a < c```,
но при указанном варианте перегрузки может произойти сравнение
```c < a```, которое окажется верным, что всё ломает
).


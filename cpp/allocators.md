# Аллокаторы

### Понятие аллокатора

Работать с памятью напрямую через операторы ```new, delete``` не принято.
Принято выполнять все подобные операции через класс-прослойку под названием аллокатор.

Что такое аллокатор?

Аллокатор - это шаблонный класс, предназначенный для выделения и удаления памяти 
под объекты данного типа.

Аллокатор должен представлять два метода: ```allocate, deallocate```.

```allocate``` принимает параметр ```n``` - кол-во штук объектов, 
на которые надо выделить память,
а ```deallocate``` принимает указатель и по историческим причинам ещё параметр ```size_t```
(позже разберёмся, что за он).

Стандартный аллокатор(```std::allocator<T>```) - просто прослойка, чтобы напрямую не писать 
```new```.

В большинстве контейнеров в шаблоне вы могли видеть аллокатор как параметр, 
т.е. его можно подменить своей реализацией с указанными методами.

Зачем это может быть нужно?

Стандартный аллокатор не соптимизирован под вашу программу. 
Выделение памяти делается ОС, а ОС не знает, 
куски какого размера наперёд вы собираетесь запрашивать.
Вы же, как разработчик, наперёд можете знать, какого вида запросы могут приходить,
и потому можете выбрать наиболее оптимальную стратегию выделения памяти.
И данную стратегию вы можете реализовать через аллокатор, подменив им стандартный.

> Как пример нестадартного аллокатора можно привести аллокатор, 
> который заранее выделяет огромный кусок памяти, а потом исходя из каких-то соображений
> отдаёт небольший кусочки памяти из этого большого пулла
> (например отдавать из самого левого, подходящего по размеру, или из самого большого куска).

Приведём примерную реализацию стандартного аллокатора:

```cpp
namespace std {
template <class T>
struct allocator {
  T* allocate(size_t n) {
    return ::operator new(n * sizeof(T)); 
    // вызываем глобальную функцию, 
    // потому что не нужно вызывать констуктор
  }

  // по стандарту требуется, чтобы в deallocate передавалось 
  // то же самое size_t n, что приходило и в allocate(как и T* p)
  // иначе ub
  void deallocate(T* p, size_t) {
    ::operator delete(p); // OC помнит, сколько байт выделила по конкретному указателю
  }
}
} // namespace std
```

В принципе это почти все нужные методы для аллокатора, 
но на данном этапе мы только выделяем память,
а надо бы ещё вызывать конструктор.
Т.к. контейнер напрямую не может работать с ```new```, 
то у аллокатора ещё может быть метод ```construct```:

```cpp
template <typename ...Args>
void construct(T* p, Args&& ...args) {
  new(p) T(std::forward<Args>(args)...);
}
```

Т.е. на выделенной памяти мы создаём объект с помощью данного метода.
Писать свой метод может понадобиться в случае, если мы например хотим 
логировать все подобные операции или запретить создавать объект с конкретными параметрами.

Также стоит отметить, что реализация метода ```construct```(как и ```destroy```) необязательна. 
И если вы не напишете его, контейнер некоторым образом проверит, реализован ли данный метод, 
и если нет, вызовет стандартный.
Этим занимается ```std::allocator_traits``` с помощью техники SFINAE.

По аналогии есть метод ```destroy```:

```cpp
void destroy(T* p) {
  p->~T();
}
```

> Заметки:
> 
> 1. С точки зрения стандартного аллокатора все эти методы можно пометить ```const```.
> 
> ```allocate``` не может быть ```noexcept```, т.к. конструктор может бросить исключение.
> 
> ```deallocate``` конечно лучше ```noexcept``` не помечать, но можно сказать, что он 
> ```noexcept``` в зависимости от того, ```noexcept``` ли ```::operator delete(p)```.
> 
> ```construct``` можно пометить ```noexcept(noexcept(T(args...)))```.
> 
> ```destroy``` ```noexcept``` по умолчанию(деструкторы лучше именно так и помечать).
> 
> 2. В аллокаторе должен быть определён ```value_type```:
> 
> ```cpp
> using value_type = T;
> ```
> 
> Это нужно, чтобы пользователь аллокатора мог узнать, от чего данный аллокатор.
> Множество других typedef'ов реализует ```std::allocator_traits```.

### allocator_traits

Мы рассмотрели 4 метода аллокаторов, 2 из которых обязательны, а 2 нет. 
Однако с С++17 ```construct``` и ```destroy``` у стандартного аллокатора уже не реализованы,
т.к. они реализованы на ещё одном уровне прослойки, которая занимается тем, чтобы
дореализовывать методы за аллокатором, которые нереализованны в нём самом.

Что такое ```traits``` в С++? Это такой класс, 
который содержит определение вещей для какого-то метатипа.
Т.е. ```allocator traits``` - это такая "штука", которая определяет за аллокатор всё то,
что он не доопределил.

```cpp
// все методы статические
template <typename Alloc>
struct allocator_traits {
  // приведём реализацию allocate
  // стандартный аллокатор не меняется, но кастомный может, потому передаём по ссылке 
  static Alloc::value_type* allocate(Alloc& alloc, size_t n) { 
    return alloc.allocate(n);
  }
  // аналогично deallocate
  
  // для написания construct/destroy нужно использовать SFINAE
}
```

> Давайте улучшим ```push_back```.
> 
> Помним, что у вектора есть шаблонный параметр ```Alloc alloc```
> (а также нужные поля
> ```size_t size, capacity; T* arr```.
> 
> ```cpp
> void push_back(const T& x) {
>   using traits = std::allocator_traits<Alloc>;
>   if (size == capacity) {
>     T* new_arr = traits::allocate(alloc, capacity <<= 1);
>     for (size_t i = 0; i < sz; ++i) {
>       // если не move, то будет копирование
>       traits::construct(alloc, new_arr + i, std::move_if_noexcept(arr[i]));
>     }
>     // не стоит делать всё в одном цикле, т.к.
>     // push_back даёт гарантию, что в случае, когда вылетит исключение,
>     // ничего не сломается, а если всё делать в одном цикле, мы не сможем
>     // вернуть уничтоженные объекты(если возвращать их обратно,
>     // то что, если опять исключение? 
>     // а так мы просто вернёмся к ситуации до push_back)
>     for (size_t i = 0; i < sz; ++i) {
>       traits::destroy(alloc, arr + i);
>     }
>     traits::deallocate(alloc, arr, sz);
>     arr = new_arr;
>   }
>   traits::construct(alloc, arr + sz++, x);
> }
> ```

### select_on_container_copy_construction

Что делать с аллокатором, если мы хотим скопировать, например, вектор?

В случае стандартного аллокатора проблем нет, т.к. он не хранить никаких полей,
а все вызовы - просто обёртка над ```new```. 
Его конструктор копирования имеет пустое тело.

В случае кастомного аллокатора копирование может быть нетривиальным. 
Например что делать, если аллокатор выделяет огромный пулл памяти заранее,
а потом как-то выдаёт небольшими кусками?
Как тут стоит поступить: выделять такой же пулл или просто давать один пулл обоим аллокаторам.
И вот чтобы различать копирование аллокатора и контейнера на аллокаторе существует вот такая
методология. Иногда мы не хотим копировать весь аллокатор, копируя контейнер, ведь может нам
нужна та же сущность аллокатора, что бы на ней же выделять память.
И вот чтобы решить в момент копирования контейнера, хотим ли мы копировать ещё и аллокатор,
существует такой метод, который должен быть определён у аллокатора, который либо
возвращает копию аллокатора, либо ссылку на изначальный. 
Т.е. в момент копирования вектора аллокатор инициализируется не ```alloc(other.alloc)```, а
```alloc(alloc.select_on_container_copy_construction())```. 
И стоит понимать, что аллокатор не обязан определять этот метод, тогда вызов делается так:

```cpp
std::allocator_traits<Alloc>::select_on_container_copy_construction(alloc);
```

И если метод неопределён, то аллокатор будет просто скопирован.

### one more thing

Предположим, что мы пишем свой ```std::list```, который хранит ```int```.
И соответственно отдаём ему ```allocator<int>```.
Но ```list``` же не хранит числа, он хранит ноды, а аллокатор у нас создан для чисел.
Что делать?

На самом деле ```allocator``` может предоставлять ```typedef``` под названием ```rebind```.
Т.е. имея аллокатор, мы можем захотеть получить точно такой же аллокатор, но для другого типа.
И можем написать:

```cpp
template <typename U>
using rebind::other = allocator<U>;
```

Это нужно для того, когда кто-то пользуется вашим аллокатором, мог попросить 
```allocator::rebind<U>::other```. 
Опять же можно не определять, и ```allocator_traits``` это доопределит.

### Источники

Можно почитать статьи/посмотреть доклады:
1. [Базовые концепции аллокаторов](https://habr.com/ru/post/590415/).
2. [Аллокаторы внутри](https://habr.com/ru/post/645137/).
3. CppCon 2015. Andrei Alexandrescu.
[std::allocator](https://www.youtube.com/watch?v=LIb3L4vKZ7U).
